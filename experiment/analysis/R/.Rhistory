overlaps2 = function(t1Start,t1End,t2Start,t2End){
if(t1Start < t2Start){
return(t1End - t2Start)
} else{
return(t2End - t1Start)
}
}
plotTurn = function(sigs1,sigs2){
plot(range(c(sigs1$signalStart,sigs1$signalStart,sigs1$signalEnd,sigs1$signalEnd)),c(1,nrow(sigs1)+0.5), type='n',yaxt='n')
arrows(sigs1$signalStart,
1:nrow(sigs1),
sigs1$signalEnd,
1:nrow(sigs1),
code=3, angle=90)
arrows(sigs2$signalStart,
1:nrow(sigs2)+0.5,
sigs2$signalEnd,
1:nrow(sigs2)+0.5,
code=3, angle=90
, col=2)
}
basedir = "../../data/csv/"
d = data.frame()
files = list.files(basedir , pattern = "*.csv")
for(f in files){
dx = read.csv(paste(basedir,f,sep=''), stringsAsFactors = F)
d = rbind(d,dx)
}
d$trialString = paste(d$condition,d$dyadNumber, d$game,d$trial)
unique(d$dyadNumber)
table(d$dyadNumber,d$condition)
# This file loads the data in ../data/csv/*.csv and compiles it into a single file
#  plus some handy variables
library(gplots)
# 16 trials per game
# 64 per block
# 128 per experiment
# 1920 trials in 15 dyads
source("multiHist.R")
setwd("~/Documents/MPI/ViniciusMultimodal/multimodalCommunicationGame/experiment/analysis/R/")
overlaps = function(sigs1,sigs2, margin=50){
# Are there any overlaps between the list of two communicative acts
# turns must have at least 'margin' overlap to count
inside = outer(sigs1$signalEnd,sigs2$signalStart, "-")
outside = outer(sigs1$signalStart,sigs2$signalEnd, "-")
overlap = (inside>margin) & (outside<0)
numberOfOverlaps=sum(overlap)
propOverlapsActs = numberOfOverlaps / max(dim(inside))
proportionOfOverlapsTime = apply(
cbind(
-(outside/inside)[overlap],
-(inside/outside)[overlap])
,1,min)
return(list(
numberOfOverlaps=numberOfOverlaps,
propOverlapsTime=proportionOfOverlapsTime,
propOverlapsActs = propOverlapsActs))
}
overlaps2 = function(t1Start,t1End,t2Start,t2End){
if(t1Start < t2Start){
return(t1End - t2Start)
} else{
return(t2End - t1Start)
}
}
plotTurn = function(sigs1,sigs2){
plot(range(c(sigs1$signalStart,sigs1$signalStart,sigs1$signalEnd,sigs1$signalEnd)),c(1,nrow(sigs1)+0.5), type='n',yaxt='n')
arrows(sigs1$signalStart,
1:nrow(sigs1),
sigs1$signalEnd,
1:nrow(sigs1),
code=3, angle=90)
arrows(sigs2$signalStart,
1:nrow(sigs2)+0.5,
sigs2$signalEnd,
1:nrow(sigs2)+0.5,
code=3, angle=90
, col=2)
}
basedir = "../../data/csv/"
d = data.frame()
files = list.files(basedir , pattern = "*.csv")
for(f in files){
dx = read.csv(paste(basedir,f,sep=''), stringsAsFactors = F)
d = rbind(d,dx)
}
d$trialString = paste(d$condition,d$dyadNumber, d$game,d$trial)
experDetails = read.delim("../../data/ExperimentDetails.tab",sep='\t', stringsAsFactors = F)
experDetails$dyad = paste("D",experDetails$dyad,sep='')
rownames(experDetails) = experDetails$dyad
d$modalityCondition = experDetails[d$dyadNumber,]$condition
# we don't have info on when the very last trial of each block ends, so assume it's the end of the trial
d[d$game==3 & d$trial==15,]$startOfNextTrial = d[d$game==3 & d$trial==15,]$trialEnd
# fix stuff
table(d$dyadNumber,factor(d$trial))
table(d$dyadNumber,factor(d$game),factor(d$trial))
checkForGaps = table(d$dyadNumber,factor(d$game),factor(d$trial))
sum(checkForGaps==0)
which(checkForGaps==0)
which(checkForGaps==0, arr.ind=T)
checkForGaps = table(d$dyadNumber,d$game,d$trial)
sum(checkForGaps==0)
checkForGaps
checkForGaps = table(d$dyadNumber,d$game,d$trial)
sum(checkForGaps==0)
gaps = which(checkForGaps==0, arr.ind=T)
gaps
unique(d$dyadNumber)
for(i in 1:nrow(gaps)){
print(
c(sort(unique(d$dyadNumber))[gaps[i,1]],
sort(unique(d$game))[gaps[i,2]],
sort(unique(d$trial))[gaps[i,3]])
)
}
for(i in 1:nrow(gaps)){
print(
c(sort(unique(d$dyadNumber))[gaps[i,1]],
"Game",sort(unique(d$game))[gaps[i,2]],
"Trial",sort(unique(d$trial))[gaps[i,3]])
)
}
try(setwd("~/Documents/MPI/ViniciusMultimodal/multimodalCommunicationGame/experiment/analysis/R/"))
d = read.csv("../../data/FinalSignalData.csv")
hist(d$trialLength)
range(d$trialLength)
d$trialLength.log = log(d$trialLength)
hist(d$trialLength.log)
d$trialLength.log = log(d$trialLength)
d$trialLength.log = d$trialLength.log - mean(d$trialLength.log)
hist(d$trialLength.log)
head(d)
# This file loads the data in ../data/csv/*.csv and compiles it into a single file
#  plus some handy variables
library(gplots)
# 16 trials per game
# 64 per block
# 128 per experiment
# 1920 trials in 15 dyads
source("multiHist.R")
setwd("~/Documents/MPI/ViniciusMultimodal/multimodalCommunicationGame/experiment/analysis/R/")
overlaps = function(sigs1,sigs2, margin=50){
# Are there any overlaps between the list of two communicative acts
# turns must have at least 'margin' overlap to count
inside = outer(sigs1$signalEnd,sigs2$signalStart, "-")
outside = outer(sigs1$signalStart,sigs2$signalEnd, "-")
overlap = (inside>margin) & (outside<0)
numberOfOverlaps=sum(overlap)
propOverlapsActs = numberOfOverlaps / max(dim(inside))
proportionOfOverlapsTime = apply(
cbind(
-(outside/inside)[overlap],
-(inside/outside)[overlap])
,1,min)
return(list(
numberOfOverlaps=numberOfOverlaps,
propOverlapsTime=proportionOfOverlapsTime,
propOverlapsActs = propOverlapsActs))
}
overlaps2 = function(t1Start,t1End,t2Start,t2End){
if(t1Start < t2Start){
return(t1End - t2Start)
} else{
return(t2End - t1Start)
}
}
plotTurn = function(sigs1,sigs2){
plot(range(c(sigs1$signalStart,sigs1$signalStart,sigs1$signalEnd,sigs1$signalEnd)),c(1,nrow(sigs1)+0.5), type='n',yaxt='n')
arrows(sigs1$signalStart,
1:nrow(sigs1),
sigs1$signalEnd,
1:nrow(sigs1),
code=3, angle=90)
arrows(sigs2$signalStart,
1:nrow(sigs2)+0.5,
sigs2$signalEnd,
1:nrow(sigs2)+0.5,
code=3, angle=90
, col=2)
}
basedir = "../../data/csv/"
d = data.frame()
files = list.files(basedir , pattern = "*.csv")
for(f in files){
dx = read.csv(paste(basedir,f,sep=''), stringsAsFactors = F)
d = rbind(d,dx)
}
d$trialString = paste(d$condition,d$dyadNumber, d$game,d$trial)
experDetails = read.delim("../../data/ExperimentDetails.tab",sep='\t', stringsAsFactors = F)
experDetails$dyad = paste("D",experDetails$dyad,sep='')
rownames(experDetails) = experDetails$dyad
d$modalityCondition = experDetails[d$dyadNumber,]$condition
d$playerId = paste(d$dyadNumber,d$signallingPlayer)
# we don't have info on when the very last trial of each block ends, so assume it's the end of the trial
d[d$game==3 & d$trial==15,]$startOfNextTrial = d[d$game==3 & d$trial==15,]$trialEnd
# fix stuff
d$turnType  = gsub("\\.","",d$turnType)
checkForGaps = table(d$dyadNumber,d$game,d$trial)
sum(checkForGaps==0)
gaps = which(checkForGaps==0, arr.ind=T)
for(i in 1:nrow(gaps)){
print(
c(sort(unique(d$dyadNumber))[gaps[i,1]],
"Game",sort(unique(d$game))[gaps[i,2]],
"Trial",sort(unique(d$trial))[gaps[i,3]])
)
}
# Exclude cases
# Remove first turn by matcher
d = d[d$turnType!='T0',]
##############################
# Are there any turns that belong to two trials?
# This can happen if the turns overlap with two trials
# If so, just match the turn with the trial with which it overlaps the most
d$turnString = paste(d$condition,d$modalityCondition,d$dyadNumber,d$turnStart,d$turnEnd)
numTrials = tapply(d$trialString, d$turnString,function(X){length(unique(X))})
casesToExclude = c()
for(turnName in names(numTrials[numTrials>1])){
dx = d[turnString == turnName,]
t1 = dx[dx$trial==min(dx$trial),][1,]
t2 = dx[dx$trial==max(dx$trial),][1,]
t1and2= rbind(t1,t2)[order(c(t1$trialStart,t2$trialEnd)),]
turnS = t1$turnStart[1]
turnE = t1$turnEnd[1]
overlap1 = overlaps2(t1$trialStart[1],t1$trialEnd[1],turnS,turnE)
overlap2 = overlaps2(t2$trialStart[1],t2$trialEnd[1],turnS,turnE)
if(overlap1 > overlap2){
# delete t2
casesToExclude  = c(casesToExclude,
which(d$turnString==turnName & d$trialString==t2$trialString))
} else{
# delete t1
casesToExclude  = c(casesToExclude,
which(d$turnString==turnName & d$trialString==t1$trialString))
}
}
# take out cases
d = d[- casesToExclude,]
# work out trail length
#  From start of first turn to when the listener selects a meaning.
#  The trials track the matchers turn, so that the end of the trial is when
#  the matcher makes a choice.
trialLengths = tapply(d$trialEnd, d$trialString, max)- tapply(d$turnStart, d$trialString, head,n=1)
d$trialLength = trialLengths[d$trialString]
d = d[d$trialLength> 2000,]
d$correct = d$correct=="Correct"
# Write the data to a main file
write.csv(d,"../../data/FinalSignalData.csv")
m0 = lmer(trialLength ~ 1 + (1|dyadNumber) + (1|playerId),
data=d)
library(lme4)
head(d)
d$itemId = paste(d$condition,d$target)
# This file loads the data in ../data/csv/*.csv and compiles it into a single file
#  plus some handy variables
library(gplots)
# 16 trials per game
# 64 per block
# 128 per experiment
# 1920 trials in 15 dyads
source("multiHist.R")
setwd("~/Documents/MPI/ViniciusMultimodal/multimodalCommunicationGame/experiment/analysis/R/")
overlaps = function(sigs1,sigs2, margin=50){
# Are there any overlaps between the list of two communicative acts
# turns must have at least 'margin' overlap to count
inside = outer(sigs1$signalEnd,sigs2$signalStart, "-")
outside = outer(sigs1$signalStart,sigs2$signalEnd, "-")
overlap = (inside>margin) & (outside<0)
numberOfOverlaps=sum(overlap)
propOverlapsActs = numberOfOverlaps / max(dim(inside))
proportionOfOverlapsTime = apply(
cbind(
-(outside/inside)[overlap],
-(inside/outside)[overlap])
,1,min)
return(list(
numberOfOverlaps=numberOfOverlaps,
propOverlapsTime=proportionOfOverlapsTime,
propOverlapsActs = propOverlapsActs))
}
overlaps2 = function(t1Start,t1End,t2Start,t2End){
if(t1Start < t2Start){
return(t1End - t2Start)
} else{
return(t2End - t1Start)
}
}
plotTurn = function(sigs1,sigs2){
plot(range(c(sigs1$signalStart,sigs1$signalStart,sigs1$signalEnd,sigs1$signalEnd)),c(1,nrow(sigs1)+0.5), type='n',yaxt='n')
arrows(sigs1$signalStart,
1:nrow(sigs1),
sigs1$signalEnd,
1:nrow(sigs1),
code=3, angle=90)
arrows(sigs2$signalStart,
1:nrow(sigs2)+0.5,
sigs2$signalEnd,
1:nrow(sigs2)+0.5,
code=3, angle=90
, col=2)
}
basedir = "../../data/csv/"
d = data.frame()
files = list.files(basedir , pattern = "*.csv")
for(f in files){
dx = read.csv(paste(basedir,f,sep=''), stringsAsFactors = F)
d = rbind(d,dx)
}
d$trialString = paste(d$condition,d$dyadNumber, d$game,d$trial)
experDetails = read.delim("../../data/ExperimentDetails.tab",sep='\t', stringsAsFactors = F)
experDetails$dyad = paste("D",experDetails$dyad,sep='')
rownames(experDetails) = experDetails$dyad
d$modalityCondition = experDetails[d$dyadNumber,]$condition
d$playerId = paste(d$dyadNumber,d$signallingPlayer)
d$itemId = paste(d$condition,d$target)
# we don't have info on when the very last trial of each block ends, so assume it's the end of the trial
d[d$game==3 & d$trial==15,]$startOfNextTrial = d[d$game==3 & d$trial==15,]$trialEnd
# fix stuff
d$turnType  = gsub("\\.","",d$turnType)
checkForGaps = table(d$dyadNumber,d$game,d$trial)
sum(checkForGaps==0)
gaps = which(checkForGaps==0, arr.ind=T)
for(i in 1:nrow(gaps)){
print(
c(sort(unique(d$dyadNumber))[gaps[i,1]],
"Game",sort(unique(d$game))[gaps[i,2]],
"Trial",sort(unique(d$trial))[gaps[i,3]])
)
}
# Exclude cases
# Remove first turn by matcher
d = d[d$turnType!='T0',]
##############################
# Are there any turns that belong to two trials?
# This can happen if the turns overlap with two trials
# If so, just match the turn with the trial with which it overlaps the most
d$turnString = paste(d$condition,d$modalityCondition,d$dyadNumber,d$turnStart,d$turnEnd)
numTrials = tapply(d$trialString, d$turnString,function(X){length(unique(X))})
casesToExclude = c()
for(turnName in names(numTrials[numTrials>1])){
dx = d[turnString == turnName,]
t1 = dx[dx$trial==min(dx$trial),][1,]
t2 = dx[dx$trial==max(dx$trial),][1,]
t1and2= rbind(t1,t2)[order(c(t1$trialStart,t2$trialEnd)),]
turnS = t1$turnStart[1]
turnE = t1$turnEnd[1]
overlap1 = overlaps2(t1$trialStart[1],t1$trialEnd[1],turnS,turnE)
overlap2 = overlaps2(t2$trialStart[1],t2$trialEnd[1],turnS,turnE)
if(overlap1 > overlap2){
# delete t2
casesToExclude  = c(casesToExclude,
which(d$turnString==turnName & d$trialString==t2$trialString))
} else{
# delete t1
casesToExclude  = c(casesToExclude,
which(d$turnString==turnName & d$trialString==t1$trialString))
}
}
# take out cases
d = d[- casesToExclude,]
# work out trail length
#  From start of first turn to when the listener selects a meaning.
#  The trials track the matchers turn, so that the end of the trial is when
#  the matcher makes a choice.
trialLengths = tapply(d$trialEnd, d$trialString, max)- tapply(d$turnStart, d$trialString, head,n=1)
d$trialLength = trialLengths[d$trialString]
d = d[d$trialLength> 2000,]
d$correct = d$correct=="Correct"
# Write the data to a main file
write.csv(d,"../../data/FinalSignalData.csv")
m0 = lmer(trialLength ~ 1 +
(1|dyadNumber) + (1|playerId) + (1|itemId),
data=d)
m0 = lmer(trialLength ~ 1 +
(1|dyadNumber) + (1|playerId) + (1|itemId),
data=d)
m1 = lmer(trialLength ~ 1 + modalityCondition +
(1|dyadNumber) + (1|playerId) + (1|itemId),
data=d)
m2 = lmer(trialLength ~ 1 + modalityCondition + condition +
(1|dyadNumber) + (1|playerId) + (1|itemId),
data=d)
m3 = lmer(trialLength ~ 1 + modalityCondition + condition + game +
(1|dyadNumber) + (1|playerId) + (1|itemId),
data=d)
m4 = lmer(trialLength ~ 1 + modalityCondition * condition + game +
(1|dyadNumber) + (1|playerId) + (1|itemId),
data=d)
m5 = lmer(trialLength ~ 1 + modalityCondition * condition + game + (game:condition) +
(1|dyadNumber) + (1|playerId) + (1|itemId),
data=d)
m6 = lmer(trialLength ~ 1 + modalityCondition * condition * game +
(1|dyadNumber) + (1|playerId),
data=d)
anova(m0,m1,m2,m3,m4,m5,m6)
m0 = lmer(trialLength ~ 1 +
(1|dyadNumber) + (1|playerId) + (1|itemId),
data=d)
m1 = lmer(trialLength ~ 1 + modalityCondition +
(1|dyadNumber) + (1|playerId) + (1|itemId),
data=d)
m2 = lmer(trialLength ~ 1 + modalityCondition + condition +
(1|dyadNumber) + (1|playerId) + (1|itemId),
data=d)
m3 = lmer(trialLength ~ 1 + modalityCondition + condition + game +
(1|dyadNumber) + (1|playerId) + (1|itemId),
data=d)
m4 = lmer(trialLength ~ 1 + modalityCondition * condition + game +
(1|dyadNumber) + (1|playerId) + (1|itemId),
data=d)
m5 = lmer(trialLength ~ 1 + (modalityCondition * condition) + game + (game:condition) +
(1|dyadNumber) + (1|playerId) + (1|itemId),
data=d)
m6 = lmer(trialLength ~ 1 + modalityCondition * condition * game +
(1|dyadNumber) + (1|playerId),
data=d)
anova(m0,m1,m2,m3,m4,m5,m6)
library(sjmisc)
library(sjPlot)
sjp.lmer(m6, 'fe')
?sjp.lmer
sjp.lmer(m6, 'fe', sort.est=NULL)
names(fixef(m6))
matrix(c(
"(Intercept)"             ,"Intercept"      ,
"modalityConditionvisual" ,"Visual modality",
"modalityConditionvocal"  , "Acoustic modality",
"conditionVisual" , "Visual stimuli",
"game"             , "Game",
"modalityConditionvisual:conditionVisual"  , "Visual modality:Visual stimuli",
"modalityConditionvocal:conditionVisual" , "Acoustic modality:Visual stimuli",
"modalityConditionvisual:game"    , "Visual modality:Game",
"modalityConditionvocal:game"     , "Acoustic modality:Game",
"conditionVisual:game"             , "Visual stimuli:Game",
"modalityConditionvisual:conditionVisual:game", "Visual modality:Visual stimuli:game",
"modalityConditionvocal:conditionVisual:game", "Acoustic modality:Visual stimuli:game"
), ncol=2)
match(names(fixef(m6)),feLabels[,1])
feLabels = matrix(c(
"(Intercept)"             ,"Intercept"      ,
"modalityConditionvisual" ,"Visual modality",
"modalityConditionvocal"  , "Acoustic modality",
"conditionVisual" , "Visual stimuli",
"game"             , "Game",
"modalityConditionvisual:conditionVisual"  , "Visual modality:Visual stimuli",
"modalityConditionvocal:conditionVisual" , "Acoustic modality:Visual stimuli",
"modalityConditionvisual:game"    , "Visual modality:Game",
"modalityConditionvocal:game"     , "Acoustic modality:Game",
"conditionVisual:game"             , "Visual stimuli:Game",
"modalityConditionvisual:conditionVisual:game", "Visual modality:Visual stimuli:game",
"modalityConditionvocal:conditionVisual:game", "Acoustic modality:Visual stimuli:game"
), ncol=2)
match(names(fixef(m6)),feLabels[,1])
names(fixef(m6)
names(fixef(m6))
feLabels
feLabels = matrix(c(
"(Intercept)"             ,"Intercept"      ,
"modalityConditionvisual" ,"Visual modality",
"modalityConditionvocal"  , "Acoustic modality",
"conditionVisual" , "Visual stimuli",
"game"             , "Game",
"modalityConditionvisual:conditionVisual"  , "Visual modality:Visual stimuli",
"modalityConditionvocal:conditionVisual" , "Acoustic modality:Visual stimuli",
"modalityConditionvisual:game"    , "Visual modality:Game",
"modalityConditionvocal:game"     , "Acoustic modality:Game",
"conditionVisual:game"             , "Visual stimuli:Game",
"modalityConditionvisual:conditionVisual:game", "Visual modality:Visual stimuli:game",
"modalityConditionvocal:conditionVisual:game", "Acoustic modality:Visual stimuli:game"
), ncol=2, byrow = T)
match(names(fixef(m6)),feLabels[,1])
feLabels[match(names(fixef(m6)),feLabels[,1]),2]
feLabels2 = feLabels[match(names(fixef(m6)),feLabels[,1]),2]
sjp.lmer(m6, 'fe',
sort.est=NULL,
axis.labels = feLabels2)
sjp.lmer(m6, 'fe',
show.intercept = T,
sort.est=NULL,
axis.labels = feLabels2)
feLabels2
feLabels2 = as.vector(feLabels[match(names(fixef(m6)),feLabels[,1]),2])
feLabels2
length(feLabels2)
length(fixef(m6))
sjp.lmer(m6, 'fe',
show.intercept = T,
sort.est=NULL,
axis.labels = feLabels2)
sjp.lmer(m6, 'fe',
show.intercept = T,
sort.est=NULL,
axis.labels = feLabels2[2:12])
library(car)
library(pbkrtest)
sjp.lmer(m6, 'fe',
show.intercept = T,
sort.est=NULL,
axis.labels = feLabels2[2:12],
xlab="Trial time (ms)")
sjp.lmer(m6, 'fe',
show.intercept = T,
sort.est=NULL,
axis.labels = feLabels2[2:12],
xlab="Trial time (ms)",
show.ci=T)
sjp.lmer(m6, 'fe',
show.intercept = T,
sort.est=NULL,
axis.labels = feLabels2[2:12],
xlab="Trial time (ms)",
geom.colors = c(1))
