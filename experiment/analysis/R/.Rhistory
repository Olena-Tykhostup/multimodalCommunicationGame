#  From start of first turn to when the listener selects a meaning.
#  The trials track the matchers turn, so that the end of the trial is when
#  the matcher makes a choice.
trialLengths = tapply(d$trialEnd, d$trialString, max)- tapply(d$turnStart, d$trialString, head,n=1)
d$trialLength = trialLengths[d$trialString]
d = d[d$trialLength> 2000,]
d$correct = d$correct=="Correct"
# Check for gaps again
checkForGaps = table(d$dyadNumber,d$condition,d$game,d$trial)
sum(checkForGaps==0)
gaps = which(checkForGaps==0, arr.ind=T)
if(nrow(gaps)>0){
cat("",file="../../processing/ListOfTrialsWithoutTurns.txt")
for(i in 1:nrow(gaps)){
cat(
paste(
sort(unique(d$dyadNumber))[gaps[i,1]],
"Signals",sort(unique(d$condition))[gaps[i,2]],
"Game",sort(unique(d$game))[gaps[i,3]],
"Trial",sort(unique(d$trial))[gaps[i,4]],"\n", sep=' '),
file = "../../processing/ListOfTrialsWithoutTurns.txt",
append = T
)
}
}
# Write the data to a main file
write.csv(d,"../../data/FinalSignalData.csv")
library(gplots)
setwd("~/Documents/MPI/ViniciusMultimodal/multimodalCommunicationGame/experiment/analysis/R/")
d = read.csv("../../data/FinalSignalData.csv")
overlaps = function(sigs1,sigs2, margin=50){
# Are there any overlaps between the list of two communicative acts
# turns must have at least 'margin' overlap to count
inside = outer(sigs1$signalEnd,sigs2$signalStart, "-")
outside = outer(sigs1$signalStart,sigs2$signalEnd, "-")
overlap = (inside>margin) & (outside<0)
numberOfOverlaps=sum(overlap)
propOverlapsActs = numberOfOverlaps / max(dim(inside))
proportionOfOverlapsTime = apply(
cbind(
-(outside/inside)[overlap],
-(inside/outside)[overlap])
,1,min)
return(list(
numberOfOverlaps=numberOfOverlaps,
propOverlapsTime=proportionOfOverlapsTime,
propOverlapsActs = propOverlapsActs))
}
overlaps2 = function(t1Start,t1End,t2Start,t2End){
if(t1Start < t2Start){
return(t1End - t2Start)
} else{
return(t2End - t1Start)
}
}
############
# Turn level data
turnD = data.frame()
# For each trial
for(turn in unique(d$turnString)){
turnData = d[d$turnString == turn,]
numModalitiesUsed = length(unique(turnData$modality))
useVisual = "Visual" %in% turnData$modality
useAcoustic = "Acoustic" %in% turnData$modality
numberOfOverlaps = 0
propOverlapsActs = 0
propOverlapsTime = 0
numberOfMultimodalSigs = 0
# numberOfVisualSigs = sum(turnData$modality=="Visual")
# numberOfAcousticSigs = sum(turnData$modality=="Acoustic")
numberOfSignals = nrow(turnData)
if(numModalitiesUsed==2){
ol = overlaps(
sigs1 = turnData[turnData$modality=="Visual",],
sigs2 = turnData[turnData$modality=="Acoustic",]
)
numberOfOverlaps = ol$numberOfOverlaps
propOverlapsTime = mean(ol$propOverlapsTime)
propOverlapsActs = ol$propOverlapsActs
numberOfMultimodalSigs = numberOfOverlaps
# numberOfVisualSigs = sum(turnData$modality=="Visual") - numberOfOverlaps
# numberOfAcousticSigs = sum(turnData$modality=="Acoustic") - numberOfOverlaps
}
ret = cbind(
turnData[1,],
numModalitiesUsed,
numberOfOverlaps,
propOverlapsTime,
propOverlapsActs,
useVisual,
useAcoustic,
numberOfSignals,
numberOfMultimodalSigs
)
turnD = rbind(turnD,ret)
}
turnD = turnD[,!names(turnD) %in% c("signalStart",'signalEnd','signalLength','signalType')]
turnD$turnModalityType = "none"
turnD$turnModalityType[turnD$numberOfMultimodalSigs>0] = "multi"
turnD$turnModalityType[turnD$numberOfMultimodalSigs==0 & turnD$useVisual & turnD$useAcoustic] = "unimodal mixed"
turnD$turnModalityType[turnD$numberOfMultimodalSigs==0 & turnD$useVisual & (!turnD$useAcoustic)] = "unimodal visual"
turnD$turnModalityType[(!turnD$useVisual) & turnD$useAcoustic] = "unimodal acoustic"
turnD$turnModalityType = as.factor(turnD$turnModalityType)
table(turnD$useVisual,turnD$useAcoustic)
table(turnD[turnD$turnType=="T1" & turnD$modalityCondition=='multi',]$turnModalityType,
turnD[turnD$turnType=="T1" & turnD$modalityCondition=='multi',]$condition)
range(turnD$numberOfMultimodalSigs)
matrix(
unlist(
tapply(
turnD$turnModalityType,
turnD$dyadNumber,
table)),
ncol=3
)
plotmeans(propOverlapsTime~ condition,
data=turnD[turnD$modalityCondition=='multi' & turnD$turnModalityType=="multi",])
# Write the data out
write.csv(turnD,"../../data/Final_Turn_data.csv", row.names = F)
# This file creates mirrored histograms, and also the data file "../../data/Final_Multimodal_data.csv"
library(gplots)
setwd("~/Documents/MPI/ViniciusMultimodal/multimodalCommunicationGame/experiment/analysis/R/")
d = read.csv("../../data/FinalSignalData.csv", stringsAsFactors = F)
# load function to make mirrored plots
source("multiHist.R")
getPropTimeAcoustic = function(acousticSel,visualSel){
# Add the signal time for each modality for each trial
acousticTime = tapply(d[acousticSel,]$signalLength,
d[acousticSel,]$trialString,
sum)
visualTime = tapply(d[visualSel,]$signalLength,
d[visualSel,]$trialString,
sum)
dyads.vis = tapply(d[visualSel,]$dyadNumber,
d[visualSel,]$trialString,
head,n=1)
games.vis = tapply(d[visualSel,]$game,
d[visualSel,]$trialString,
head,n=1)
dyads.ac = tapply(d[acousticSel,]$dyadNumber,
d[acousticSel,]$trialString,
head,n=1)
games.ac = tapply(d[acousticSel,]$game,
d[acousticSel,]$trialString,
head,n=1)
# Make sure there's a time for each trial
# if the trial time is NA, set it to zero
allTrials = unique(d[d$modalityCondition=="multi",]$trialString)
visualTime= visualTime[allTrials]
visualTime[is.na(visualTime)] = 0
acousticTime= acousticTime[allTrials]
acousticTime[is.na(acousticTime)] = 0
propAcousticSignals = acousticTime / (acousticTime+visualTime)
propAcousticSignals[is.nan(propAcousticSignals)] = NA
names(propAcousticSignals) = allTrials
#propAcousticSignals = propAcousticSignals[!is.na(propAcousticSignals)]
#x = hist(propAcousticSignals, plot = F)
#x$counts = x$counts/length(unique(d[d$modalityCondition=="multi",]$trialString))
#plot(x, ylab="Proportion of trials")
propAcousticSignals_AuditoryStim =
propAcousticSignals[grepl("Auditory",names(propAcousticSignals))]
propAcousticSignals_VisualStim =
propAcousticSignals[grepl("Visual",names(propAcousticSignals))]
return(list(propAcousticSignals_AuditoryStim=propAcousticSignals_AuditoryStim,
propAcousticSignals_VisualStim=propAcousticSignals_VisualStim,
dayds.ac= dyads.ac[!is.na(dyads.ac)],
games.ac = games.ac[!is.na(games.ac)],
dyads.vis=dyads.vis[!is.na(dyads.vis)],
games.vis=games.vis[!is.na(games.vis)]
))
}
############
mx = d[d$modalityCondition=='multi',]
mx = mx[!duplicated(mx$trialString),]
# which cases are T1s with acoustic/visual signals?
acousticT1s = d$modalityCondition=="multi" & d$turnType=='T1' & d$modality=="Acoustic"
visualT1s = d$modalityCondition=="multi" & d$turnType=='T1' & d$modality=="Visual"
x = getPropTimeAcoustic(acousticT1s,visualT1s)
propAcousticSignals_AuditoryStim = x[[1]]
propAcousticSignals_VisualStim = x[[2]]
dyads_propAcousticSignals_A= x[[3]]
games_propAcousticSignals_A= x[[4]]
dyads_propAcousticSignals_V= x[[5]]
games_propAcousticSignals_V= x[[6]]
mx$T1.propAc = c(propAcousticSignals_AuditoryStim,
propAcousticSignals_VisualStim
)[mx$trialString]
# Plot histograms
cols= c(rgb(0,1,0,0.5),rgb(1,0,0,0.5))
breaks = seq(0,1,0.05)
hist(propAcousticSignals_AuditoryStim, col=cols[1], border=cols[1], breaks=breaks)
hist(propAcousticSignals_VisualStim, add=T, col=cols[2], border = cols[2], breaks=breaks)
# Mirrored histogram
pdf("../../results/graphs/PropModality/PropModality_T1.pdf")
multhist(propAcousticSignals_AuditoryStim,propAcousticSignals_VisualStim,
bin.width=0.05,
col=c(2,3),
dir=c(1,-1),
main="T1",
legends = c("Auditory","Visual"),
xlab="Proportion of Acoustic signals",
ylab="Number of trials")
dev.off()
acousticDirector = d$modalityCondition=="multi" & d$role=="Director" & d$modality=="Acoustic"
visualDirector = d$modalityCondition=="multi" & d$role=="Director" & d$modality=="Visual"
x = getPropTimeAcoustic(acousticDirector ,visualDirector)
propAcousticSignals_AuditoryStim_director = x[[1]]
propAcousticSignals_VisualStim_director = x[[2]]
pdf("../../results/graphs/PropModality/PropModality_Director.pdf")
multhist(propAcousticSignals_AuditoryStim_director,
propAcousticSignals_VisualStim_director,
bin.width=0.05,
col=c(2,3),
dir=c(1,-1),
main="Director Turns",
legends = c("Auditory","Visual"),
xlab="Proportion of Acoustic signals",
ylab="Number of trials")
dev.off()
############
# T2
acousticT2s = d$modalityCondition=="multi" & d$turnType=='T2' & d$modality=="Acoustic"
visualT2s = d$modalityCondition=="multi" & d$turnType=='T2' & d$modality=="Visual"
x = getPropTimeAcoustic(acousticT2s,visualT2s)
propAcousticSignals_AuditoryStimT2 = x[[1]]
propAcousticSignals_VisualStimT2 = x[[2]]
mx$T2.propAc = c(propAcousticSignals_AuditoryStimT2,
propAcousticSignals_VisualStimT2
)[mx$trialString]
# Mirrored histogram
pdf("../../results/graphs/PropModality/PropModality_T2.pdf")
multhist(propAcousticSignals_AuditoryStimT2,propAcousticSignals_VisualStimT2,
bin.width=0.05,
col=c(1,2),
dir=c(1,-1),
main='T2',
legends = c("Auditory","Visual"),
xlab="Proportion of Acoustic signals",
ylab="Number of trials")
dev.off()
############
# T3 and beyond for Director
acousticT3s = d$modalityCondition=="multi" &
d$turnType!='T1' & d$role=="Director" &
d$modality=="Acoustic"
visualT3s = d$modalityCondition=="multi" &
d$turnType!='T1' & d$role=="Director" &
d$modality=="Visual"
x = getPropTimeAcoustic(acousticT3s,visualT3s)
propAcousticSignals_AuditoryStimT3 = x[[1]]
propAcousticSignals_VisualStimT3 = x[[2]]
mx$T3Plus.propAc = c(propAcousticSignals_AuditoryStimT3,
propAcousticSignals_VisualStimT3
)[mx$trialString]
# Mirrored histogram
pdf("../../results/graphs/PropModality/PropModality_Director_postT1.pdf")
multhist(propAcousticSignals_AuditoryStimT3,propAcousticSignals_VisualStimT3,
bin.width=0.05,
col=c(1,2),
dir=c(1,-1),
main='T3',
legends = c("Auditory","Visual"),
xlab="Proportion of Acoustic signals",
ylab="Number of trials")
dev.off()
# T4 and beyond for Matcher
acousticT4s = d$modalityCondition=="multi" &
d$turnType!='T2' & d$role=="Director" &
d$modality=="Acoustic"
visualT4s = d$modalityCondition=="multi" &
d$turnType!='T2' & d$role=="Director" &
d$modality=="Visual"
x = getPropTimeAcoustic(acousticT4s,visualT4s)
propAcousticSignals_AuditoryStimT4 = x[[1]]
propAcousticSignals_VisualStimT4 = x[[2]]
mx$T4Plus.propAc = c(propAcousticSignals_AuditoryStimT4,
propAcousticSignals_VisualStimT4
)[mx$trialString]
# All director turns
acousticD = d$modalityCondition=="multi" &
d$role=="Director" &
d$modality=="Acoustic"
visualD = d$modalityCondition=="multi" &
d$role=="Director" &
d$modality=="Visual"
x = getPropTimeAcoustic(acousticD,visualD)
propAcousticSignals_AuditoryStimD = x[[1]]
propAcousticSignals_VisualStimD = x[[2]]
mx$Director.propAc = c(propAcousticSignals_AuditoryStimD,
propAcousticSignals_VisualStimD
)[mx$trialString]
# All matcher turns
acousticM = d$modalityCondition=="multi" &
d$role!="Director" &
d$modality=="Acoustic"
visualM = d$modalityCondition=="multi" &
d$role!="Director" &
d$modality=="Visual"
x = getPropTimeAcoustic(acousticM,visualM)
propAcousticSignals_AuditoryStimM = x[[1]]
propAcousticSignals_VisualStimM = x[[2]]
mx$Matcher.propAc = c(propAcousticSignals_AuditoryStimM,
propAcousticSignals_VisualStimM
)[mx$trialString]
### How many turns have multimodal utts?
getMultimodalUttsPerTurn <- function(turnSel){
dx = d[turnSel,]
# if there's only one signal, or only one modality used
if(nrow(dx)==1 | length(unique(dx$modality))==1){
return(list(mutli=0, total=nrow(dx)))
}
}
for(turn in unique(d$turnString)){
turnSel = d$modalityCondition=='multi' & d$turnString==turn
}
write.csv(mx,"../../data/Final_Multimodal_Trial_data.csv", row.names = F)
###############
library(lattice)
xyplot(trialLength/1000~game | dyadNumber+condition,
data=d[d$modalityCondition=="multi",],
type='a',
ylim=c(0,40),
main="Trial length in the multimodal condition")
xyplot(propAcousticSignals_AuditoryStim~games_propAcousticSignals_A|factor(dyads_propAcousticSignals_A), type='p')
xyplot(propAcousticSignals_VisualStim~games_propAcousticSignals_V|factor(dyads_propAcousticSignals_V), type='p')
library(gplots)
setwd("~/Documents/MPI/ViniciusMultimodal/multimodalCommunicationGame/experiment/analysis/R/")
d = read.csv("../../data/FinalSignalData.csv")
d$game = d$game +1
#d = d[d$correct,]
plotmeans(trialLength~paste(modalityCondition,condition),
data=d[!duplicated(d$trialString),],
connect=list(1:2,3:4,5:6))
pdf("../../results/graphs/Efficiency.pdf", width=10, height=6)
par(mfrow=c(1,2))
for(stimType in unique(d$condition)){
plotmeans(trialLength/1000~game,
data = d[d$modalityCondition=='vocal' & !duplicated(d$trialString)
& d$condition==stimType,],
col=1,barcol = 1,n.label = F,
ylim=c(0,20),
xlab="Game",
ylab="Trial length (s)", las=1)
plotmeans(trialLength/1000~game,
data = d[d$modalityCondition=='multi' & !duplicated(d$trialString)
& d$condition==stimType,],
add=T,col=2,barcol = 2,
xaxt='n',
n.label = F)
plotmeans(trialLength/1000~game,
data = d[d$modalityCondition=='visual' & !duplicated(d$trialString)
& d$condition==stimType,],
add=T,col=3,barcol = 3,n.label = F,
xaxt='n')
if(stimType=="Auditory"){
legend(2.5,20,legend=c('Acoustic','Multimodal','Visual'), col=1:3,lty=1,pch=1)
}
title(main=stimType)
}
dev.off()
pdf("../../results/graphs/Accuracy.pdf", width=10, height=6)
par(mfrow=c(1,2))
for(stimType in unique(d$condition)){
plotmeans(correct~game,
data = d[d$modalityCondition=='vocal' & !duplicated(d$trialString)
& d$condition==stimType,],
col=1,barcol = 1,n.label = F,
ylim=c(0,1),
xlab="Game",
ylab="Accuracy", las=1)
plotmeans(correct~game,
data = d[d$modalityCondition=='multi' & !duplicated(d$trialString)
& d$condition==stimType,],
add=T,col=2,barcol = 2,
xaxt='n',
n.label = F)
plotmeans(correct~game,
data = d[d$modalityCondition=='visual' & !duplicated(d$trialString)
& d$condition==stimType,],
add=T,col=3,barcol = 3,n.label = F,
xaxt='n')
if(stimType=="Auditory"){
legend(2.5,0.5,legend=c('Acoustic','Multimodal','Visual'), col=1:3,lty=1,pch=1)
}
title(main=stimType)
}
dev.off()
library(gplots)
library(RColorBrewer)
setwd("~/Documents/MPI/ViniciusMultimodal/multimodalCommunicationGame/experiment/analysis/R/")
d = read.csv("../../data/FinalSignalData.csv")
d$game = d$game + 1
numberOfRepairs = tapply(d$turnType, d$trialString, function(X){
sum(X %in% c("T2","T4","T6",'T8','T10'))
})
condition = tapply(d$condition, d$trialString, head,n=1)
modalityCondition = tapply(d$modalityCondition, d$trialString, head,n=1)
game = tapply(d$game, d$trialString, head,n=1)
categories = paste(modalityCondition,condition,game)
plotmeans(numberOfRepairs[modalityCondition=="vocal" & condition=="Auditory"]~
categories[modalityCondition=="vocal" & condition=="Auditory"],
connect=T,
xaxt='n',
xlab='Condition',
ylab="Number of repairs")
axis(1,at=c(1.5,3.5,5.5), c("Multimodal",'Visual',"Vocal"))
visual = table(d[d$condition=="Visual",]$turnType %in% c("T2","T4","T6",'T8','T10'),
d[d$condition=="Visual",]$game,
d[d$condition=="Visual",]$modalityCondition)
auditory = table(d[d$condition=="Auditory",]$turnType %in% c("T2","T4","T6",'T8','T10'),
d[d$condition=="Auditory",]$game,
d[d$condition=="Auditory",]$modalityCondition)
cols = brewer.pal(3,'Pastel1')
yrange = c(0,35)
pdf("../../results/graphs/Repairs/TotalNumberOfRepairs.pdf",
width=10, height=5)
par(mfrow=c(1,2))
barplot(t(visual[2,,]), beside=T,
xlab='Game',
ylab="Total number of repairs",
col = cols,
main = "Visual stimuli",
ylim=yrange)
barplot(t(auditory[2,,]), beside=T,
xlab='Game',
ylab="Total number of repairs",
col = cols,
main = "Auditory stimuli",
ylim=yrange)
legend(10, yrange[2], legend=c("Multimodal",'Visual',"Vocal"),
pch=15,
col = cols)
dev.off()
blocXmod = lmer(trialLength.log ~ 1 + modalityCondition * condition * trialTotal +
I(trialTotal^2) +
(incorrect*condition*modalityCondition)+
(modalityCondition:I(trialTotal^2)) +
firstBlock * modalityCondition +
(1 + condition + incorrect |dyadNumber/playerId) +
(1 + modalityCondition|itemId),
data=d)
---
title: "Modality effects in a signalling game"
output: pdf_document
knit: (function(inputFile, encoding) { rmarkdown::render(inputFile, encoding = encoding, output_file = file.path(dirname(inputFile), "../../results/MainResults_Efficiency.pdf")) })
---
# Intro
This script uses data compiled by *analyseData.R*.
## Load libraries
```{r warning=FALSE, message=FALSE}
library(lme4)
library(sjPlot)
library(ggplot2)
library(lattice)
library(influence.ME)
```
```{r echo=F}
try(setwd("~/Documents/MPI/ViniciusMultimodal/multimodalCommunicationGame/experiment/analysis/R/"))
```
## Load data
```{r}
d = read.csv("../../data/FinalSignalData.csv")
```
We don't need info on every signal in each turn, just the trial time.  Keep only 1st signal in each trial.
```{r}
d = d[!duplicated(d$trialString),]
```
# Descriptive stats
Here is a graph showing the distribution of trial lengths by conditions:
![The efficiency of trials in different conditions](../../results/graphs/Efficiency.pdf)
The distribution of trial times is very skewed:
```{r}
hist(d$trialLength)
```
So we transform it using a log transform, then center the data.
```{r}
d$trialLength.log = log(d$trialLength)
meanLogTrialLength = mean(d$trialLength.log)
d$trialLength.log = d$trialLength.log - meanLogTrialLength
hist(d$trialLength.log)
```
Make a variable to represent proportion of games played:
```{r}
# Make a variable that represents the number of trials played
d$trialTotal = d$trial + (d$game * (max(d$trial)+1))
# Convert to proportion of games played, so that estimates reflect change per game.
d$trialTotal = d$trialTotal / 16
# Center the trialTotal variable so intercept reflects after the first game
d$trialTotal = d$trialTotal - 1
```
Make a variable for which stimuli the players experienced first.
```{r}
firstBlock = tapply(as.character(d$condition),d$dyadNumber,head,n=1)
d$firstBlock = as.factor(firstBlock[match(d$dyadNumber,names(firstBlock))])
```
Reorder some levels so that the intercept reflects the most frequent condition.
```{r}
d$incorrect = !d$correct
```
blocXmod = lmer(trialLength.log ~ 1 + modalityCondition * condition * trialTotal +
I(trialTotal^2) +
(incorrect*condition*modalityCondition)+
(modalityCondition:I(trialTotal^2)) +
firstBlock * modalityCondition +
(1 + condition + incorrect |dyadNumber/playerId) +
(1 + modalityCondition|itemId),
data=d)
fixef(blocXmod)
x = fixef(blocXmod)
x[grepl("incor",x)]
grepl("incor",x)
x[grepl("incor",names(x))]
