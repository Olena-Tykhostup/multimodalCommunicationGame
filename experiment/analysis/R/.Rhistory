#Each row in the data is a single response from a participant to a single sample. The key variables are:
# PartID: identifies participants
# trial: identifies unique trial
# Animal_pair: identifies character pairs used in stimuli
# Diff_level: the level of the difficulty of the trial
# length: length of the entire utterance for the trial quantified as total number of Movement Segments (MS) per trial
#OUTCOCOME VARIABLES:
#length: number of MS in total for each trial
#simult_total: proportion of movement segments containing kinematically simultaneous articulators encdoding distinct meaning (2 articulators or more)
#devided by total number of MS used for each trial
#2sim: proprtion of MS with 2 simultaneous information units
#devided by total number of MS containing simultaneous information units in a trial
#3sim: shows proprtion of MS with 3 simultaneous infoirmation units
#devided by total number of MS containing simultaneous information units in a trial
#4sim: shows proprtion of MS with 4 simultaneous information units
#devided by total number of MS containing simultaneous information units in a trial
#prepare data sets for further analyses for various simulatneous density (to accoutn for 2, 3 and 4 units in data)
d_D1_out = d[d$Diff_level!= "D1",]
d_D1D2_out = d_D1_out[d_D1_out$Diff_level!= "D2",]
d_D1D2D3_out = d_D1D2_out[d_D1D2_out$Diff_level!= "D3",]
```
mDiff = glmer(
length ~ 1 + Diff_level +
(1 | PartID) +
(1 | trial),
data = d,
family=poisson(link = "log")
)
summary(mDiff)
m0 = glmer(
length ~ 1 +
(1 | PartID) +
(1 | trial),
data = d,
family=poisson(link = "log")
)
anova(m0, mDiff)
table(d$PartID,d$Animal_pair)
table(d$PartID,d$Diff_level)
table(d$PartID,d$trial)
---
title: "Simultaneity"
author: "Anita Slonimska"
date: "3/19/2019"
---
```{r setup, include=FALSE}
##load libraries
library(reshape2)
library(plyr)
library(lme4)
library(lattice)
library(scales)
library(ggplot2)
library(sjPlot)
library(Rmisc)
library(dplyr)
library(nlme)
library(optimx)
library(magrittr)
library (sicegar)
library(lmerTest)
library(RColorBrewer)
library(devtools)
library(piecewiseSEM)
library(MuMIn)
library(dplyr)
library(minqa)
d <- read.delim2("~/Downloads/masterfile_sign_R.txt")
#get the total number of simultaneous signs (movement segments)
d$simult_kinem <- (d$two_info+ d$three_info+d$four_info)
names(d)[names(d) == "movement_units"] <- "length"
#add column with unique trial - combination of animal pair and difficulty level -
#to account for per item variation later on
d$trial <- paste(d$Animal_pair, d$Diff_level, sep=",")
d$Diff_level[d$Diff_level == "1"] <- "D1"
d$Diff_level[d$Diff_level == "2"] <- "D2"
d$Diff_level[d$Diff_level == "3"] <- "D3"
d$Diff_level[d$Diff_level == "4"] <- "D4"
d$Diff_level[d$Diff_level == "5"] <- "D5"
d$Animal_pair <- as.factor(d$Animal_pair)
d$Diff_level <- as.factor(d$Diff_level)
d$trial <- as.factor(d$trial)
d$length <- as.numeric(d$length)
d$one_info <- as.numeric(d$one_info)
d$two_info <- as.numeric(d$two_info)
d$three_info <- as.numeric(d$three_info)
d$four_info <- as.numeric(d$four_info)
d$PartID <- as.factor(d$PartID)
d$Age <- as.numeric(d$Age)
d$Sex <- as.factor(d$Sex)
d$Hand <- as.factor(d$Hand)
#Each row in the data is a single response from a participant to a single sample. The key variables are:
# PartID: identifies participants
# trial: identifies unique trial
# Animal_pair: identifies character pairs used in stimuli
# Diff_level: the level of the difficulty of the trial
# length: length of the entire utterance for the trial quantified as total number of Movement Segments (MS) per trial
#OUTCOCOME VARIABLES:
#length: number of MS in total for each trial
#simult_total: proportion of movement segments containing kinematically simultaneous articulators encdoding distinct meaning (2 articulators or more)
#devided by total number of MS used for each trial
#2sim: proprtion of MS with 2 simultaneous information units
#devided by total number of MS containing simultaneous information units in a trial
#3sim: shows proprtion of MS with 3 simultaneous infoirmation units
#devided by total number of MS containing simultaneous information units in a trial
#4sim: shows proprtion of MS with 4 simultaneous information units
#devided by total number of MS containing simultaneous information units in a trial
#prepare data sets for further analyses for various simulatneous density (to accoutn for 2, 3 and 4 units in data)
d_D1_out = d[d$Diff_level!= "D1",]
d_D1D2_out = d_D1_out[d_D1_out$Diff_level!= "D2",]
d_D1D2D3_out = d_D1D2_out[d_D1D2_out$Diff_level!= "D3",]
library(REEMtree)
?REEMtree(Diff_level,d,random=1|)
?REEMtree
head(d)
?REEMtree(Diff_level~sim2.p+sim3.p+sim4p,d,random=1|PartID + 1|trial)
t = REEMtree(Diff_level~sim2.p+sim3.p+sim4.p,d,random=1|PartID + 1|trial)
t = REEMtree(Diff_level~sim2.p+sim3.p+sim4.p,d,random=list(1|PartID, 1|trial))
t = REEMtree(Diff_level~sim2.p+sim3.p+sim4.p,d)
names(d)
d$sim2.p
# For some reason, the sim.p and other proportion fields are being
# converted to a factor. So convert back to a number:
d$sim.p = as.numeric(as.character(d$sim.p))
d$sim2.p = as.numeric(as.character(d$sim2.p))
d$sim3.p = as.numeric(as.character(d$sim3.p))
d$sim4.p = as.numeric(as.character(d$sim4.p))
t = REEMtree(Diff_level~sim2.p+sim3.p+sim4.p,d,random=list(1|PartID, 1|trial))
d$Diff_level
d$sim.p
d$sim2.p
d$sim3.p
d$sim4.p
t = REEMtree(Diff_level~sim2.p+sim3.p+sim4.p,d,random=1|PartID)
d$PartID
d$PartID = as.character(d$PartID)
t = REEMtree(Diff_level~sim2.p+sim3.p+sim4.p,d,random=1|PartID)
t = REEMtree(as.numeric(Diff_level)~sim2.p+sim3.p+sim4.p,d,random=1|PartID)
d$Diff_level=as.numeric(d$Diff_level)
t = REEMtree(Diff_level~sim2.p+sim3.p+sim4.p,d,random=1|PartID)
t = REEMtree(Diff_level~sim2.p+sim3.p+sim4.p,d[complete.cases(d),],random=1|PartID)
library(party)
t = ctree(Diff_level~sim2.p+sim3.p+sim4.p,d)
plot(t)
d$Diff_level = factor(d$Diff_level)
t = ctree(Diff_level~sim2.p+sim3.p+sim4.p,d)
plot(t)
?lmer
library(lme4)
?lmer
?glmer
?glm
r = function(){
max(sample(1:20, 2))
}
replicate(5,r)
r = function(){
return(max(sample(1:20, 2)))
}
replicate(5,r())
r = function(){
return(max(sample(1:20, 2)+4))
}
replicate(5,r())
r = function(){
return(max(sample(1:20, 2)+4))
}
replicate(5,r())
replicate(6,r())
replicate(6,r())
replicate(6,r())
library(lme4)
?binomial
?glmer
---
title: "Modality effects in a signalling game: Accuracy"
output:
pdf_document:
toc: true
includes:
in_header: header.tex
knit: (function(inputFile, encoding) { rmarkdown::render(inputFile, encoding = encoding, output_file = file.path(dirname(inputFile), "../../results/MainResults_Accuracy.pdf")) })
---
# Intro
This script uses data compiled by *analyseData.R*.
## Load libraries
```{r warning=FALSE, message=FALSE}
library(lme4)
library(sjPlot)
library(ggplot2)
library(lattice)
library(influence.ME)
library(party)
library(dplyr)
```
```{r echo=F}
try(setwd("~/Documents/MPI/ViniciusMultimodal/multimodalCommunicationGame/experiment/analysis/R/"))
```
## Load data
```{r}
d = read.csv("../../data/FinalSignalData.csv")
```
Work out number of turns in each trial.
```{r}
# Number of turns in each trial
numTurns = tapply(d$turnString, d$trialString,
function(X){length(unique(X))})
d$numberOfTurns = numTurns[d$trialString]
```
Variable for length of first T1
```{r}
T1L = tapply(d[d$turnType=="T1",]$turnLength,
d[d$turnType=="T1",]$trialString, head, n=1)
d$T1Length = T1L[d$trialString]
d$T1Length[is.na(d$T1Length)] = mean(d$T1Length,na.rm=T)
d$T1Length.log = log(d$T1Length)
d$T1Length.log = d$T1Length.log - mean(d$T1Length.log)
```
Did matcher respond?
```{r}
matcherResponds = tapply(d$turnType, d$trialString, function(X){
any(X %in% c("T2","T4","T6","T8",'T10'))
})
d$matcherResponds = matcherResponds[d$trialString]
```
We don't need info on every signal in each turn, just the trial time.  Keep only 1st signal in each trial.
```{r}
d = d[!duplicated(d$trialString),]
```
gc = glmerControl(optimizer = "bobyqa" ,optCtrl = list(maxfun=50000))
m0.int =  glmer(correct ~ 1 +
(1 |dyadNumber/playerId) +
(1 |itemId) ,
data=d, family=binomial,
control = gc)
game = glmer(correct ~ 1 +
trialTotal +
(1 + condition |dyadNumber/playerId) +
(1 + modalityCondition |itemId) ,
data=d, family=binomial,
control = gc)
d$trialLength.log = log(d$trialLength)
meanLogTrialLength = mean(d$trialLength.log)
---
title: "Modality effects in a signalling game: Accuracy"
output:
pdf_document:
toc: true
includes:
in_header: header.tex
knit: (function(inputFile, encoding) { rmarkdown::render(inputFile, encoding = encoding, output_file = file.path(dirname(inputFile), "../../results/MainResults_Accuracy.pdf")) })
---
# Intro
This script uses data compiled by *analyseData.R*.
## Load libraries
```{r warning=FALSE, message=FALSE}
library(lme4)
library(sjPlot)
library(ggplot2)
library(lattice)
library(influence.ME)
library(party)
library(dplyr)
```
```{r echo=F}
try(setwd("~/Documents/MPI/ViniciusMultimodal/multimodalCommunicationGame/experiment/analysis/R/"))
```
## Load data
```{r}
d = read.csv("../../data/FinalSignalData.csv")
```
Work out number of turns in each trial.
```{r}
# Number of turns in each trial
numTurns = tapply(d$turnString, d$trialString,
function(X){length(unique(X))})
d$numberOfTurns = numTurns[d$trialString]
```
Variable for length of first T1
```{r}
T1L = tapply(d[d$turnType=="T1",]$turnLength,
d[d$turnType=="T1",]$trialString, head, n=1)
d$T1Length = T1L[d$trialString]
d$T1Length[is.na(d$T1Length)] = mean(d$T1Length,na.rm=T)
d$T1Length.log = log(d$T1Length)
d$T1Length.log = d$T1Length.log - mean(d$T1Length.log)
```
Did matcher respond?
```{r}
matcherResponds = tapply(d$turnType, d$trialString, function(X){
any(X %in% c("T2","T4","T6","T8",'T10'))
})
d$matcherResponds = matcherResponds[d$trialString]
```
We don't need info on every signal in each turn, just the trial time.  Keep only 1st signal in each trial.
```{r}
d = d[!duplicated(d$trialString),]
```
# Descriptive stats
Here is a graph showing the distribution of accuracy by conditions:
```{r}
summary = d %>%
group_by(condition, modalityCondition,game) %>%
summarise(Accuracy=mean(correct),
sd=sd(correct),
ci.w =           qnorm(0.95)*sd/sqrt(length(correct)),
upper=Accuracy+ci.w,
lower = Accuracy-ci.w)
summary$game = summary$game +1
summary$modalityCondition =
factor(summary$modalityCondition,
levels = c("visual",'multi','vocal'),
labels=c("Gestural","Multimodal","Vocal"))
#ggplot(d, aes(x=trialTotal, y=as.numeric(correct),colour=modalityCondition)) +
#  geom_smooth() + facet_grid(.~condition)
#ggplot(d, aes(x=trialTotal, y=as.numeric(correct),colour=condition)) +
#  geom_smooth() + #facet_grid(.~modalityCondition)
ggplot(summary, aes(x=game, y=Accuracy, group=condition, colour=modalityCondition)) +
geom_point() +
geom_errorbar(aes(ymin=lower, ymax=upper)) +
facet_grid(. ~ condition) +
stat_summary(fun.y="mean", geom="line", aes(group=modalityCondition))
gx = ggplot(summary, aes(x=game, y=Accuracy, group=condition, colour=condition, shape=condition)) +
geom_point() +
geom_errorbar(aes(ymin=lower, ymax=upper)) +
facet_grid(. ~ modalityCondition) +
stat_summary(fun.y="mean", geom="line", aes(group=condition)) +
scale_colour_brewer(palette="Dark2",name="Stimuli") +
scale_shape_discrete(name="Stimuli") +
xlab("Game")
gx
pdf("../../results/graphs/Accuracy_gg.pdf",
width = 5, height=3)
gx
dev.off()
pd = position_dodge(width=0.5)
gx1 = ggplot(summary, aes(x=game, y=Accuracy, group=condition, colour=modalityCondition)) +
geom_errorbar(aes(ymin=lower, ymax=upper,group=modalityCondition), width=0.5,position = pd) +
stat_summary(fun.y="mean", geom="line", aes(group=modalityCondition),position = pd) +
geom_point(aes(group=modalityCondition,shape=modalityCondition),position=pd) +
scale_colour_brewer(palette="Set2", name="Condition") +
scale_shape(name="Condition") +
ggtitle("Accuracy") +
theme(panel.grid.major.x = element_blank()) +
facet_grid(. ~ condition) +
xlab("Game")
gx1
pdf("../../results/graphs/Accuracy_gg_alt.pdf",
width = 5, height=3)
gx1
dev.off()
```
\newpage
Make a variable to represent proportion of games played:
```{r}
# Make a variable that represents the number of trials played
d$trialTotal = d$trial + (d$game * (max(d$trial)+1))
# Convert to proportion of games played, so that estimates reflect change per game.
d$trialTotal = d$trialTotal / 16
# Center the trialTotal variable so intercept reflects after the first game
d$trialTotal = d$trialTotal
```
Average accuracy per dyad:
```{r}
av.acc = tapply(d$correct, d$dyadNumber, function(X){sum(X)/length(X)})
mean(av.acc)
```
Make a variable for which stimuli the players experienced first.
```{r}
firstBlock = tapply(as.character(d$condition),d$dyadNumber,head,n=1)
d$firstBlock = as.factor(firstBlock[match(d$dyadNumber,names(firstBlock))])
```
Variable to indicate whether T1 is multimodal.
```{r}
turnD = read.csv("../../data/Final_Turn_data.csv")
turnD = turnD[turnD$turnType=="T1",]
turnD = turnD[turnD$role == "Director",]
d$multimodal = turnD[match(d$trialString, turnD$trialString),]$turnModalityType == "multi"
d$multimodal[is.na(d$multimodal)] = F
```
Make a variable to represent proportion of games played:
```{r}
# Make a variable that represents the number of trials played
d$trialTotal = d$trial + (d$game * (max(d$trial)+1))
# Convert to proportion of games played, so that estimates reflect change per game.
d$trialTotal = d$trialTotal / 16
# Center the trialTotal variable so intercept reflects after the first game
d$trialTotal = d$trialTotal - 2
```
Transformed trial time.
```{r}
d$trialLength.log = log(d$trialLength)
meanLogTrialLength = mean(d$trialLength.log)
d$trialLength.log = d$trialLength.log - meanLogTrialLength
```
Get an idea of the structure of the data from a binary tree:
```{r}
cx = ctree(correct ~ modalityCondition + condition +
trialTotal +
trialLength +
matcherResponds +
matcherResponds +
T1Length +
multimodal+
firstBlock,
data=d)
```
game = glmer(correct ~ 1 +
trialTotal +
(1 + condition |dyadNumber/playerId) +
(1 + modalityCondition |itemId) ,
data=d, family=binomial,
control = gc)
summary(game)
library(ggplot2)
library(RColorBrewer)
library(gridExtra)
setwd("~/Documents/MPI/ViniciusMultimodal/multimodalCommunicationGame/experiment/analysis/R/")
d = read.csv("../../data/FinalSignalData.csv",stringsAsFactors = F)
d = d[d$role=="Director" & d$turnNumber==1 & d$modalityCondition == "multi" & d$condition=='Auditory',]
multimodalSignal = tapply(d$modality, d$trialString, function(X){
length(unique(X))==2
})
d = d[d$trialString %in% names(multimodalSignal)[multimodalSignal],]
d$signalStart.R = NA
d$signalEnd.R = NA
for(ts in unique(d$trialString)){
v = d[d$trialString==ts,]$signalStart[1]
d[d$trialString==ts, ]$signalStart.R =
d[d$trialString==ts, ]$signalStart - v
d[d$trialString==ts, ]$signalEnd.R =
d[d$trialString==ts, ]$signalEnd - v
}
####
colx = c(
rgb(220,117,109,maxColorValue = 255),
rgb(117,155,252,maxColorValue = 255))
colx = c("#fc8d62","#66c2a5")
aorder = tapply(
d[d$modality=="Acoustic",]$signalStart.R,
d[d$modality=="Acoustic",]$trialString,
head, n=1)
trials = names(sort(aorder))
res = 201
cuts = seq(-0.5,1.5,length.out = res)
counts = rep(0,length.out = res)
startAndEnd = data.frame()
for(i in 1:length(trials)){
ts = trials[i]
v = d[d$trialString==ts & d$modality=='Visual',][1,]
a = d[d$trialString==ts & d$modality=='Acoustic',][1,]
aL = a$signalLength / v$signalLength
aStart = (a$signalStart - v$signalStart) / v$signalLength
aEnd = aStart + aL
startAndEnd  = rbind(startAndEnd,
data.frame(start=aStart,end=aEnd))
sel = cuts>aStart & cuts<=aEnd
counts[sel] = counts[sel] + 1
}
colx = c(
rgb(117,155,252,maxColorValue = 255),
rgb(220,117,109,maxColorValue = 255))
colx = c("#66c2a5","#8da0cb")
pdf("../../results/graphs/PropModality/TurnOverlap_Director_Multimodal_AcousticStimuli.pdf", width=5,height = 3)
par(mar=c(3,6,1,1))
barplot(counts, col=colx[2],border=colx[2],
space = 0,
ylim=c(0,300), las=1, ylab="")
text(-60,150,"Number\nof Trials",xpd=T)
rect(which(cuts==0),0,which(cuts==1),300, col='light gray', border=NA)
rect(which(cuts==0),250,which(cuts==1),300, col=colx[1], border=NA)
barplot(counts, col=colx[2],border=colx[2],
space = 0,
ylim=c(0,300), add=T, yaxt='n')
text(which(cuts==0.5),275,"Gestural", col='white')
text(which(cuts==0.5),75,"Vocal", col='white')
arrows(0, y0 = -25 ,x1=length(counts),y1=-25, xpd=T, lwd=2)
text(length(counts)/2, -40,"Time", xpd=T)
dev.off()
makeBandGraph = function(startAndEnd){
par(mar=c(1,1,1,1))
lineColours = c("#a8b6d7","#8da0cb","#506daf")
plot(c(-0.5,1.5),c(1,240),type='n',xaxt="n",yaxt='n',xlab="",ylab="",bty='n')
rect(0,230,1,250, col=colx[1], border=NA)
rect(0,0,1,230, col='#f2f2f2', border=NA)
arrows(startAndEnd$start,1:nrow(startAndEnd),startAndEnd$end,1:nrow(startAndEnd),length=0,
col = lineColours,lwd = 3,lend=2)
text(0.5,240,"Gestural", col='white',cex=2)
text(0.5,50,"Vocal", col='white',cex=4)
}
head(startAndEnd)
head(trials)
head(v)
res = 201
cuts = seq(-0.5,1.5,length.out = res)
counts = rep(0,length.out = res)
startAndEnd = data.frame()
for(i in 1:length(trials)){
ts = trials[i]
v = d[d$trialString==ts & d$modality=='Visual',][1,]
a = d[d$trialString==ts & d$modality=='Acoustic',][1,]
stimCond = d[d$trialString==ts,]$condition[1]
aL = a$signalLength / v$signalLength
aStart = (a$signalStart - v$signalStart) / v$signalLength
aEnd = aStart + aL
startAndEnd  = rbind(startAndEnd,
data.frame(start=aStart,end=aEnd,condition=stimCond))
sel = cuts>aStart & cuts<=aEnd
counts[sel] = counts[sel] + 1
}
head(startAndEnd)
table(startAndEnd$condition)
