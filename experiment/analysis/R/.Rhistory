class(tip)<-"phylo"
obj<-bind.tree(tree,tip,where=where)
return(obj)
}
setNodeToTip = function(nodeName,tree, edge.length=0.001){
bind.tip(tree,nodeName, edge.length,which(tree$node.label==nodeName)[1] + length(tree$tip.label))
}
downloadTree <- function(glottoid){
url = paste("http://glottolog.org/resource/languoid/id/",glottoid,'.newick.txt',sep='')
tx = readLines(url)
return(tx[1])
}
#' Download glottolog trees from the web and convert to phylo objects
#'
#' @param glottoid The glottoid of the family to get (will be downloaded from the web) or local filename.
#' @param nodeLabelsBy How should the node labels be returned?  Glottolog trees have nodes labelled with glottoids, language names and sometimes iso codes. Defaults to "glottoid" for returning glottoids.
#' @param langNodesToTips Some languages in glottolog are not tips on the tree, but nodes with children (e.g. for languages with dialects).  If langNodesToTips is TRUE, the returned tree has extra tips for all nodes with non-blank labels.
#' @return phylo tree
#' @keywords Glottolog
#' @export
#' @examples
#' phy <- getGlottologTree("atla1278","glottoid")
getGlottologTree <- function(glottoid, nodeLabelsBy="glottoid", langNodesToTips=F, dichotomosTree=F){
if(grepl("^[a-z][a-z][a-z][a-z][0-9][0-9][0-9][0-9]$",glottoid)){
tx = downloadTree(glottoid)
} else{
tx = readLines(glottoid)[1]
}
# Add ending semicolon so that read.newick works
if(substr(tx,nchar(tx),nchar(tx))!=";"){
tx = paste(tx,";",sep='')
}
phy<-phytools::read.newick(text=tx)
phy$tip.label = editGlottologTipLabels(phy$tip.label,nodeLabelsBy)
phy$node.label = editGlottologTipLabels(phy$node.label,nodeLabelsBy)
if(langNodesToTips){
for(nx in phy$node.label[phy$node.label!='']){
phy = setNodeToTip(nx,phy)
}
}
if(dichotomosTree){
phy = ape::multi2di(phy)
}
return(phy)
}
#
phy <- getGlottologTree("atla1278","glottoid")
phy
#' Convert golottolog tip labels
#'
#' @param X vector of labels.
#' @param nodeLabelsBy How should the node labels be returned?  Glottolog trees have nodes labelled with glottoids, language names and sometimes iso codes. Defaults to "glottoid" for returning glottoids.
#' @return vector of node labels
#' @keywords Glottolog
#' @examples
#' phy$tip.label = editGlottologTipLabels(phy$tip.label,"glottoid")
#'
editGlottologTipLabels = function(X, nodeLabelsBy="glottoid"){
item = 2 # glottoid by default
if(is.numeric(nodeLabelsBy)){
item = nodeLabelsBy
} else{
if(nodeLabelsBy=="name"){
item = 1
}
if(nodeLabelsBy=="iso"){
item = 3
}
}
X = gsub("\\]","[",X)
return(
sapply(strsplit(X,"\\["),function(z){
if(length(z)>=item){
return(z[item])
} else{
return("")
}
}))
}
bind.tip<-function(tree,tip.label,edge.length=NULL,where=NULL){
if(is.null(where)) where<-length(tree$tip)+1
tip<-list(edge=matrix(c(2,1),1,2),
tip.label=tip.label,
edge.length=edge.length,
Nnode=1)
class(tip)<-"phylo"
obj<-bind.tree(tree,tip,where=where)
return(obj)
}
setNodeToTip = function(nodeName,tree, edge.length=0.001){
bind.tip(tree,nodeName, edge.length,which(tree$node.label==nodeName)[1] + length(tree$tip.label))
}
nodesToTips = function(phy, nodesToFix = phy$node.label[phy$node.label!='']){
for(nx in nodesToFix){
phy = setNodeToTip(nx,phy)
}
return(phy)
}
downloadTree <- function(glottoid){
url = paste("http://glottolog.org/resource/languoid/id/",glottoid,'.newick.txt',sep='')
tx = readLines(url)
return(tx[1])
}
#' Download glottolog trees from the web and convert to phylo objects
#'
#' @param glottoid The glottoid of the family to get (will be downloaded from the web) or local filename.
#' @param nodeLabelsBy How should the node labels be returned?  Glottolog trees have nodes labelled with glottoids, language names and sometimes iso codes. Defaults to "glottoid" for returning glottoids.
#' @param langNodesToTips Some languages in glottolog are not tips on the tree, but nodes with children (e.g. for languages with dialects).  If langNodesToTips is TRUE, the returned tree has extra tips for all nodes with non-blank labels.
#' @return phylo tree
#' @keywords Glottolog
#' @export
#' @examples
#' phy <- getGlottologTree("atla1278","glottoid")
getGlottologTree <- function(glottoid, nodeLabelsBy="glottoid", langNodesToTips=F, dichotomosTree=F){
if(grepl("^[a-z][a-z][a-z][a-z][0-9][0-9][0-9][0-9]$",glottoid)){
tx = downloadTree(glottoid)
} else{
tx = readLines(glottoid)[1]
}
# Add ending semicolon so that read.newick works
if(substr(tx,nchar(tx),nchar(tx))!=";"){
tx = paste(tx,";",sep='')
}
phy<-phytools::read.newick(text=tx)
phy$tip.label = editGlottologTipLabels(phy$tip.label,nodeLabelsBy)
phy$node.label = editGlottologTipLabels(phy$node.label,nodeLabelsBy)
if(langNodesToTips){
phy = nodesToTips(phy)
}
if(dichotomosTree){
phy = ape::multi2di(phy)
}
return(phy)
}
#
phy <- getGlottologTree("atla1278","glottoid")
phy
?readLines
phy <- getGlottologTree("atla1278","glottoid", langNodesToTips = T)
phy
'gola1255' %in% phy$tip.labels
plot(phy)
d = read.csv("~/Downloads/midata8613.csv")
head(d)
d$X.Date
as.Date(d$X.Date)
as.Date(as.character(d$X.Date))
?as.Date(as.character(d$X.Date))
as.Date(as.character(d$X.Date),"%d/%m/%Y")
d$date = as.Date(as.character(d$X.Date),"%d/%m/%Y")
plot(d$Balance,d$date)
plot(d$Balance~d$date)
plot(d$date,d$Balance)
plot(d$date,d$Balance, type = 'line')
head(d)
head(d$Balance)
d$Balance = as.numeric(d$Balance)
d$Balance
d$date = as.Date(as.character(d$X.Date),"%d/%m/%Y")
d$date = as.Date(as.character(d$X.Date),"%d/%m/%Y")
as.numeric(as.character(substring(d$Balance,2))
head(d$Balance)
as.numeric(as.character(substring(d$Balance,2)))
d$date = as.Date(as.character(d$X.Date),"%d/%m/%Y")
head(d$Balance)
d = read.csv("~/Downloads/midata8613.csv")
d$date = as.Date(as.character(d$X.Date),"%d/%m/%Y")
head(d$Balance)
as.numeric(as.character(substring(d$Balance,2)))
substring(d$Balance,2)
?substring(d$Balance,2)
X = head(d$Balance)
X
d$Balance = as.character(d$Balance)
d$Balance
X = head(d$Balance)
substring(X,2)
substring(X,1)
substring(X,4)
substring(X,3)
as.numeric(as.character(substring(d$Balance,3)))
d = read.csv("~/Downloads/midata8613.csv")
d$date = as.Date(as.character(d$X.Date),"%d/%m/%Y")
d$Balance = as.character(d$Balance)
d$Balance = as.numeric(as.character(substring(d$Balance,3)))
plot(d$date,d$Balance, type = 'line')
abline(as.Date(2017-01-01))
abline(v=as.Date(2017-01-01))
abline(h=as.Date(2017-01-01))
as.Date(2017-01-01)
abline(h=as.Date("2017-01-01"))
abline(v=as.Date("2017-01-01"))
abline(v=as.Date("2017-02-01"))
abline(v=as.Date("2017-03-01"))
d
d[45:46,]
factor(10)
factorial(10)
factorial(20)
numberOfSamples = 137
numberOfSamples/2
68 + 68
d = read.csv("~/Documents/MPI/LuisM_K_Pronoun/data/Alldata_simple.csv", stringsAsFactors = F)
head(d)
names(d)
g = read.csv("~/Documents/MPI/Glottolog/glottolog-languoid.csv/languoid.csv",stringsAsFactors = F)
names(g)
g$family = g[match(g$family_pk,g$pk),]$name
head(g$id)
d$family = g[match(d$glotto,g$id),]$family
head(d$family)
table(d$family)
d2 = d[d$family=="Uto-Aztecan",]
table(d2$meaning.id)
table(d2$Language)
d = read.delim("~/Documents/MPI/LuisM_K_Pronoun/BEAST_analysis/models/2017/relaxedClock_excludeSmall/relaxedClock_resampled.log",sep="\t", skip = 790, nrows = 10)
head(d)
plot(d$posterior)
d = read.delim("~/Documents/MPI/LuisM_K_Pronoun/BEAST_analysis/models/2017/relaxedClock_excludeSmall/relaxedClock_resampled.log",sep="\t", skip = 790, nrows = 20000)
plot(d$posterior)
plot(log(d$posterior))
plot(log(absd$posterior))
plot(log(abs(d$posterior)))
plot((d$posterior))
plot((d$posterior[3:nrow(d)]))
library(RColorBrewer)
RColorBrewer::display.brewer.all()
?RColorBrewer::display.brewer.all()
?display.brewer.all()
RColorBrewer::display.brewer.all(colorblindFriendly=T)
?display.brewer.all(colorblindFriendly=T)
brewer.pal(4,'Dark2')
plot(1:4,col=brewer.pal(4,'Dark2'),pch=15, cex=4)
plot(1:4,col=brewer.pal(4,'Set2'),pch=15, cex=4)
plot(1:6,col=brewer.pal(6,'Set2'),pch=15, cex=4)
plot(1:6,col=brewer.pal(6,'Dark2'),pch=15, cex=4)
pi
pi*0.5
library(REEMtree)
n = 300
x = as.factor(sample(1:4,n,replace = T))
y = as.factor(sample(1:4,n,replace = T))
REEMtree(x~y)
r = as.factor(rep(1:2,n/2))
library(REEMtree)
n = 300
x = as.factor(sample(1:4,n,replace = T))
y = as.factor(sample(1:4,n,replace = T))
r = as.factor(rep(1:2,n/2))
data = data.frame(x=x,y=y,r=r)
REEMtree(x~y,data=data,random=r)
x
d = read.csv("/Library/WebServer/Documents/LED/offline/data/db/full.csv")
head(d)
---
title: "Codability across languages and domains"
output:
pdf_document:
toc: true
---
# Introduction
This document provides R code for reproducing the test of the relative codability of the senses.  We use mixed effects modelling to test the influence of language and domain.  The full model included random intercepts for stimulus, domain, language, and the interaction between language and domain.  Log-likelihood comparison was used to compare the full model to a model without one of those intercepts
## Data
The main data comes from `../data/DiversityIndices_ND.csv`, which includes the Simpson's diversity index, counting no-responses as unique responses.  Each row lists the codability of a particular stimulus for a particular community.  The variables are:
-  `Language`: Language/Community name
-  `domain`: Sense domain
-  `Stimulus.code`: Identity of the stimulus
-  `simpson.diversityIndex`: Simpson's diversity index
-  `shannon.diversityIndex`: Shannon diversity index
-  `N`: Number of responses
-  `BnL.diversityIndex`:  Brown & Lenneberg diversity index
-  `mean.number.of.words`:  Mean number of words in full response
# Load libraries
```{r message=F, warning=F}
library(lme4)
library(sjPlot)
library(REEMtree)
library(ggplot2)
library(party)
library(reshape2)
library(rpart.plot)
library(lattice)
library(dplyr)
library(mgcv)
library(lmtest)
library(itsadug)
```
```{r echo=F}
getMEText = function(r,ef, wald=NULL, showWald=F){
AIC = r[2,]$AIC
loglikDiff = signif(diff(r$logLik),2)
chi = round(r$Chisq[2],2)
df = r$`Chi Df`[2]
p = signif(r$`Pr(>Chisq)`[2],2)
wald.text = ""
if(!is.null(wald)){
est = signif(wald[1],2)
stder = signif(wald[2],2)
t = signif(wald[3],2)
wptext = ""
wald.text =  paste("beta = ",est,",")
if(showWald){
if(!is.na(wald[4])){
wptext = paste(", Wald p =",signif(wald[4],2))
}
wald.text = paste("beta = ",est,", std.err = ",stder, ", Wald t = ",t,wptext,';')
}
}
begin = 'There was no significant'
if(p <0.09){
begin = "There was a marginal"
}
if(p < 0.05){
begin = 'There was a significant'
}
return(paste(begin,ef,"(",wald.text,"log likelihood difference =",
loglikDiff,", df = ",df,", Chi Squared =", chi,", p = ",p,")."))
}
```
```{r echo=F, eval=F}
setwd("~/Documents/Bristol/Codability/LoP_Codability/analyses/")
```
# Load data
```{r}
d = read.csv("../data/DiversityIndices_ND.csv", stringsAsFactors = F)
d = d[!is.na(d$simpson.diversityIndex),]
d$Language= as.factor(d$Language)
d$domain = factor(d$domain, levels=c("colour",'shape','sound','touch','taste','smell'))
```
Get log of diversity index, (add 0.1 to avoid infinite values)
```{r}
d$logDiversity = log(d$simpson.diversityIndex+0.1)
d$L = substr(d$Language,1,3)
d$modality = "Spoken"
d$modality[d$Language %in% c("ASL", "BSL", "Kata Kolok")] = "Signed"
REEMresult.mod<-REEMtree(simpson.diversityIndex~ L + domain + modality,
data=d,
random= c(~1|Stimulus.code),
MaxIterations = 100000)
library(REEMtree)
REEMresult.mod<-REEMtree(simpson.diversityIndex~ L + domain + modality,
data=d,
random= c(~1|Stimulus.code),
MaxIterations = 100000)
rpart.plot(tree(REEMresult.mod), type=4, extra=100,
box.palette="RdYlGn")
library(rpart.plot)
rpart.plot(tree(REEMresult.mod), type=4, extra=100,
box.palette="RdYlGn")
tree(REEMresult.mod)$variable.importance
---
title: "Modality effects in a signalling game"
output: pdf_document
knit: (function(inputFile, encoding) { rmarkdown::render(inputFile, encoding = encoding, output_file = file.path(dirname(inputFile), "../../results/MainResults_Efficiency.pdf")) })
---
# Intro
The main data used in this analysis comes from `../../data/FinalSignalData.csv` (compiled by  `analyseData.R`).  Each row represents one signal, but this script only keeps one signal per trial, and the rest of the analysis is on the trial-by-trial level.  The variables in the data are as follows (some are calculated in the script below):
-  X: ID
-  filename: Filename of the ELAN file
-  dyadNumber: ID of the participant dyad
-  condition: Stimuli type (Auditory or Visual)
-  game: Game number (0-3)
-  trial: Trial number (0-15)
-  target: Target stimuli shown to the director
-  choice: Meaning chosen by the matcher
-  correct: True if the matcher's choice is correct
-  trialStart, trialEnd, trialLength: Start, end and length of trial in milliseconds
-  trialValue:  A unique string that represents data from the trial.  Numbers in the curly brackets represent the choices given to the matcher
-  startOfNextTrial: Timestamp for next trial, used in processing the data.
-  turnStart, turnEnd, turnLength: the start, end and length of the turn in milliseconds.
-  signalStart, signalEnd, signalLength: the start, end and length of the signal.
-  signalType:  Annotation value in ELAN, not meaningful
-  tiralString: Unique string to identify trial
-  modalityCondition:  The condition for the dyad (multi= multimodal, visual=gesture only, vocal=vocal only)
-  playerId:  Unique ID for the participant producing the signal
-  itemId:  Unique ID for the target stimulus
-  turnString:  Unque ID for the turn
-  matcherResponds:  Does matcher take a turn in this trial?
-  matcherResponds.cumulative: The (scaled) number of previous trials that a has responded.
-  T1Length, T1Length.log:  Length and log length of the director's first turn.
-  trialTotal: Number of trials played so far, scaled (and centered) to represent number of games played.
-  firstBlock:  Block order
-  incorrect:  Was the matcher's choice incorrect?
-  multimodal:  Was the director's first turn multimodal?
## Load libraries
```{r warning=FALSE, message=FALSE}
library(lme4)
library(sjPlot)
library(ggplot2)
library(lattice)
library(influence.ME)
library(dplyr)
```
```{r echo=F}
try(setwd("~/Documents/MPI/ViniciusMultimodal/multimodalCommunicationGame/experiment/analysis/R/"))
```
## Load data
```{r}
d = read.csv("../../data/FinalSignalData.csv")
```
Variable for length of first T1
```{r}
T1L = tapply(d[d$turnType=="T1",]$turnLength,
d[d$turnType=="T1",]$trialString, head, n=1)
d$T1Length = T1L[d$trialString]
d$T1Length[is.na(d$T1Length)] = mean(d$T1Length,na.rm=T)
d$T1Length.log = log(d$T1Length)
d$T1Length.log = d$T1Length.log - mean(d$T1Length.log)
```
We don't need info on every signal in each turn, just the trial time.  Keep only 1st signal in each trial.
```{r}
d = d[!duplicated(d$trialString),]
```
# Descriptive stats
Make a variable to represent proportion of games played:
```{r}
# Make a variable that represents the number of trials played
d$trialTotal = d$trial + (d$game * (max(d$trial)+1))
# Convert to proportion of games played, so that estimates reflect change per game.
d$trialTotal = d$trialTotal / 16
```
Here is a graph showing the distribution of trial lengths by conditions:
```{r}
summary = d %>%
group_by(condition, modalityCondition,game) %>%
summarise(Efficiency=mean(trialLength),
sd=sd(trialLength),
ci.w =           qnorm(0.95)*sd/sqrt(length(trialLength)),
upper=Efficiency+ci.w,
lower = Efficiency-ci.w)
summary$game = summary$game +1
summary$modalityCondition =
factor(summary$modalityCondition,
levels = c("visual",'multi','vocal'),
labels=c("Gestural","Multimodal","Vocal"))
ggplot(d, aes(x=trialTotal, y=trialLength,colour=modalityCondition)) +
geom_smooth() + facet_grid(.~condition)
ggplot(d, aes(x=trialTotal, y=trialLength,colour=condition)) +
geom_smooth() + facet_grid(.~modalityCondition)
gx1 = ggplot(summary, aes(x=game, y=Efficiency, group=condition, colour=modalityCondition)) +
geom_errorbar(aes(ymin=lower, ymax=upper), width=0.5) +
facet_grid(. ~ condition) +
stat_summary(fun.y="mean", geom="line", aes(group=modalityCondition)) +
geom_point() +
scale_colour_discrete(name="Condition")
gx1
pdf("../../results/graphs/Efficiency_gg.pdf",
width = 5, height=3)
gx1
dev.off()
gx2 = ggplot(summary, aes(x=game, y=Efficiency, group=condition, colour=condition, shape=condition)) +
geom_errorbar(aes(ymin=lower, ymax=upper), width=0.5) +
facet_grid(. ~ modalityCondition) +
stat_summary(fun.y="mean", geom="line", aes(group=condition)) +
geom_point() +
scale_colour_discrete(name="Stimuli") +
scale_shape_discrete(name="Stimuli") +
xlab("Game")
gx2
pdf("../../results/graphs/Efficiency_gg_alt.pdf",
width = 5, height=3)
gx2
dev.off()
```
![The efficiency of trials in different conditions](../../results/graphs/Efficiency.pdf)
Average trial time for the whole experiment:
```{r}
mean(d$trialLength)
sd(d$trialLength)
```
The distribution of trial times is very skewed:
```{r}
hist(d$trialLength)
```
So we transform it using a log transform, then center the data.
```{r}
d$trialLength.log = log(d$trialLength)
meanLogTrialLength = mean(d$trialLength.log)
d$trialLength.log = d$trialLength.log - meanLogTrialLength
hist(d$trialLength.log)
```
```{r}
# Center the trialTotal variable so intercept reflects after the first game
d$trialTotal = d$trialTotal - 2
matcherResponds.cumulative.mean = mean(d$matcherResponds.cumulative)
d$matcherResponds.cumulative = d$matcherResponds.cumulative - matcherResponds.cumulative.mean
d$matcherResponds = factor(d$matcherResponds)
```
Make a variable for which stimuli the players experienced first.
```{r}
firstBlock = tapply(as.character(d$condition),d$dyadNumber,head,n=1)
d$firstBlock = as.factor(firstBlock[match(d$dyadNumber,names(firstBlock))])
```
Reorder some levels so that the intercept reflects the most frequent condition.
```{r}
d$incorrect = !d$correct
```
Variable for whether T1 was a multimodal signal.
```{r}
turnD = read.csv("../../data/Final_Turn_data.csv")
turnD = turnD[turnD$turnType=="T1",]
turnD = turnD[turnD$role == "Director",]
d$multimodal = turnD[match(d$trialString, turnD$trialString),]$turnModalityType == "multi"
d$multimodal[is.na(d$multimodal)] = F
```
tapply(d$trialLength,d$modalityCondition,d$modality)
tapply(d$trialLength,d$modalityCondition,mean)
tapply(d$trialLength,paste(d$modalityCondition,d$modality),mean)
5947 / 10548.000
5947 - 10548.000
a = 10548.000
a * 0.56
