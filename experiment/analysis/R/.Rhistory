```
finalModel = glmer(correct ~ 1 +
modalityCondition * condition +
trialTotal +
trialLength.log +
matcherResponds.cumulative +
(1 |dyadNumber) +
(1 |itemId) ,
data=d, family=binomial,
control = gc)
---
title: "Modality effects in a signalling game: Accuracy"
output:
pdf_document:
includes:
in_header: header.tex
knit: (function(inputFile, encoding) { rmarkdown::render(inputFile, encoding = encoding, output_file = file.path(dirname(inputFile), "../../results/MainResults_Accuracy.pdf")) })
---
# Intro
This script uses data compiled by *analyseData.R*.
## Load libraries
```{r warning=FALSE, message=FALSE}
library(lme4)
library(sjPlot)
library(ggplot2)
library(lattice)
library(influence.ME)
library(party)
```
```{r echo=F}
try(setwd("~/Documents/MPI/ViniciusMultimodal/multimodalCommunicationGame/experiment/analysis/R/"))
```
## Load data
```{r}
d = read.csv("../../data/FinalSignalData.csv")
```
Work out number of turns in each trial.
```{r}
# Number of turns in each trial
numTurns = tapply(d$turnString, d$trialString,
function(X){length(unique(X))})
d$numberOfTurns = numTurns[d$trialString]
```
Variable for length of first T1
```{r}
T1L = tapply(d[d$turnType=="T1",]$turnLength,
d[d$turnType=="T1",]$trialString, head, n=1)
d$T1Length = T1L[d$trialString]
d$T1Length[is.na(d$T1Length)] = mean(d$T1Length,na.rm=T)
d$T1Length.log = log(d$T1Length)
d$T1Length.log = d$T1Length.log - mean(d$T1Length.log)
```
Did matcher respond?
```{r}
matcherResponds = tapply(d$turnType, d$trialString, function(X){
any(X %in% c("T2","T4","T6","T8",'T10'))
})
d$matcherResponds = matcherResponds[d$trialString]
```
We don't need info on every signal in each turn, just the trial time.  Keep only 1st signal in each trial.
```{r}
d = d[!duplicated(d$trialString),]
```
# Descriptive stats
Here is a graph showing the distribution of accuracy by conditions:
![The efficiency of trials in different conditions](../../results/graphs/Accuracy.pdf)
Average accuracy per dyad:
```{r}
av.acc = tapply(d$correct, d$dyadNumber, function(X){sum(X)/length(X)})
mean(av.acc)
```
Make a variable to represent proportion of games played:
```{r}
# Make a variable that represents the number of trials played
d$trialTotal = d$trial + (d$game * (max(d$trial)+1))
# Convert to proportion of games played, so that estimates reflect change per game.
d$trialTotal = d$trialTotal / 16
# Center the trialTotal variable so intercept reflects after the first game
d$trialTotal = d$trialTotal
```
Make a variable for which stimuli the players experienced first.
```{r}
firstBlock = tapply(as.character(d$condition),d$dyadNumber,head,n=1)
d$firstBlock = as.factor(firstBlock[match(d$dyadNumber,names(firstBlock))])
```
Variable to indicate whether T1 is multimodal.
```{r}
turnD = read.csv("../../data/Final_Turn_data.csv")
turnD = turnD[turnD$turnType=="T1",]
turnD = turnD[turnD$role == "Director",]
d$multimodal = turnD[match(d$trialString, turnD$trialString),]$turnModalityType == "multi"
d$multimodal[is.na(d$multimodal)] = F
```
Make a variable to represent proportion of games played:
```{r}
# Make a variable that represents the number of trials played
d$trialTotal = d$trial + (d$game * (max(d$trial)+1))
# Convert to proportion of games played, so that estimates reflect change per game.
d$trialTotal = d$trialTotal / 16
# Center the trialTotal variable so intercept reflects after the first game
d$trialTotal = d$trialTotal - 2
```
Transformed trial time.
```{r}
d$trialLength.log = log(d$trialLength)
meanLogTrialLength = mean(d$trialLength.log)
d$trialLength.log = d$trialLength.log - meanLogTrialLength
```
Get an idea of the structure of the data from a binary tree:
```{r}
cx = ctree(correct ~ modalityCondition + condition +
trialTotal +
trialLength +
matcherResponds +
matcherResponds +
T1Length +
multimodal+
firstBlock,
data=d)
```
\blandscape
```{r fig.width=20, fig.height=8}
plot(cx, terminal_panel=node_barplot(cx))
```
\elandscape
finalModel = glmer(correct ~ 1 +
modalityCondition * condition +
trialTotal +
trialLength.log +
matcherResponds.cumulative +
(1 |dyadNumber) +
(1 |itemId) ,
data=d, family=binomial,
control = gc)
gx = sjp.glmer(finalModel, 'eff', vars=c("matcherResponds.cumulative"),
title = '', prnt.plot = F,
show.ci=T, facet.grid = F)
gx
gx$plot +
xlab("Number of previous trials where\nmatcher responded") +
ylab("Probability of correct choice")
gx$plot +
xlab("Number of previous trials where\nmatcher responded") +
ylab("Probability of correct choice") +
#scale_x_continuous(breaks = c(0,5,10,15)) +
coord_cartesian(xlim=c(0,15), expand=F)
pdf("../../results/graphs/CumulativeMatcherTurns.pdf",
width=4,height=4)
gx$plot +
xlab("Number of previous trials where\nmatcher responded") +
ylab("Probability of correct choice") +
#scale_x_continuous(breaks = c(0,5,10,15)) +
coord_cartesian(xlim=c(0,15), expand=F)
dev.off()
pdf("../../results/graphs/CumulativeMatcherTurns.pdf",
width=4,height=4)
gx$plot +
xlab("Number of previous trials where\nmatcher responded") +
ylab("Probability of correct choice") +
#scale_x_continuous(breaks = c(0,5,10,15)) +
coord_cartesian(xlim=c(0,15))
dev.off()
gx$plot$theme
sjp.glmer(finalModel, 'eff',show.ci=T, facet.grid = F)
?margins
gx$plot +
xlab("Number of previous trials where\nmatcher responded") +
ylab("Probability of correct choice") +
#scale_x_continuous(breaks = c(0,5,10,15)) +
coord_cartesian(xlim=c(0,15)) +
theme(plot.margin = margin(t=0,r=0,b=0,l=0))
x = sjp.lmer(tMtchTr,'eff', 'matcherResponds.cumulative', show.ci = T, prnt.plot = F)$plot
x$data$y = exp(x$data$y + meanLogTrialLength)
x$data$ci.low = exp(x$data$lower + meanLogTrialLength)
x$data$ci.high = exp(x$data$upper + meanLogTrialLength)
x$data$x = x$data$x + matcherResponds.cumulative.mean
x$labels$title = NULL
x + #xlim(0,10) +
geom_ribbon(aes(ymin=ci.low,ymax=ci.high),alpha = 0.15) +
scale_x_continuous(limits=c(0,15)) +
#coord_cartesian(xlim = c(5, 10))  +
xlab("Number of previous trials where\nmatcher responded") +
ylab("Trial time (ms)") +
theme(strip.background = element_blank(),
strip.text.x = element_blank())
---
title: "Modality effects in a signalling game"
output: pdf_document
knit: (function(inputFile, encoding) { rmarkdown::render(inputFile, encoding = encoding, output_file = file.path(dirname(inputFile), "../../results/MainResults_Efficiency.pdf")) })
---
# Intro
This script uses data compiled by *analyseData.R*.
## Load libraries
```{r warning=FALSE, message=FALSE}
library(lme4)
library(sjPlot)
library(ggplot2)
library(lattice)
library(influence.ME)
```
```{r echo=F}
try(setwd("~/Documents/MPI/ViniciusMultimodal/multimodalCommunicationGame/experiment/analysis/R/"))
```
## Load data
```{r}
d = read.csv("../../data/FinalSignalData.csv")
```
Variable for length of first T1
```{r}
T1L = tapply(d[d$turnType=="T1",]$turnLength,
d[d$turnType=="T1",]$trialString, head, n=1)
d$T1Length = T1L[d$trialString]
d$T1Length[is.na(d$T1Length)] = mean(d$T1Length,na.rm=T)
d$T1Length.log = log(d$T1Length)
d$T1Length.log = d$T1Length.log - mean(d$T1Length.log)
```
We don't need info on every signal in each turn, just the trial time.  Keep only 1st signal in each trial.
```{r}
d = d[!duplicated(d$trialString),]
```
# Descriptive stats
Here is a graph showing the distribution of trial lengths by conditions:
![The efficiency of trials in different conditions](../../results/graphs/Efficiency.pdf)
Average trial time for the whole experiment:
```{r}
mean(d$trialLength)
sd(d$trialLength)
```
The distribution of trial times is very skewed:
```{r}
hist(d$trialLength)
```
So we transform it using a log transform, then center the data.
```{r}
d$trialLength.log = log(d$trialLength)
meanLogTrialLength = mean(d$trialLength.log)
d$trialLength.log = d$trialLength.log - meanLogTrialLength
hist(d$trialLength.log)
```
Make a variable to represent proportion of games played:
```{r}
# Make a variable that represents the number of trials played
d$trialTotal = d$trial + (d$game * (max(d$trial)+1))
# Convert to proportion of games played, so that estimates reflect change per game.
d$trialTotal = d$trialTotal / 16
# Center the trialTotal variable so intercept reflects after the first game
d$trialTotal = d$trialTotal - 2
matcherResponds.cumulative.mean = mean(d$matcherResponds.cumulative)
d$matcherResponds.cumulative = d$matcherResponds.cumulative - matcherResponds.cumulative.mean
d$matcherResponds = factor(d$matcherResponds)
```
Make a variable for which stimuli the players experienced first.
```{r}
firstBlock = tapply(as.character(d$condition),d$dyadNumber,head,n=1)
d$firstBlock = as.factor(firstBlock[match(d$dyadNumber,names(firstBlock))])
```
Reorder some levels so that the intercept reflects the most frequent condition.
```{r}
d$incorrect = !d$correct
```
Variable for whether T1 was a multimodal signal.
```{r}
turnD = read.csv("../../data/Final_Turn_data.csv")
turnD = turnD[turnD$turnType=="T1",]
turnD = turnD[turnD$role == "Director",]
d$multimodal = turnD[match(d$trialString, turnD$trialString),]$turnModalityType == "multi"
d$multimodal[is.na(d$multimodal)] = F
```
tMtchTr = lmer(trialLength.log ~ 1 +
matcherResponds +
matcherResponds.cumulative +
(1 + condition + incorrect |dyadNumber/playerId) +
(1 + modalityCondition|itemId),
data=d, REML = FALSE)
x = sjp.lmer(tMtchTr,'eff', 'matcherResponds.cumulative', show.ci = T, prnt.plot = F)$plot
x$data$y = exp(x$data$y + meanLogTrialLength)
x$data$ci.low = exp(x$data$lower + meanLogTrialLength)
x$data$ci.high = exp(x$data$upper + meanLogTrialLength)
x$data$x = x$data$x + matcherResponds.cumulative.mean
x$labels$title = NULL
x + #xlim(0,10) +
geom_ribbon(aes(ymin=ci.low,ymax=ci.high),alpha = 0.15) +
scale_x_continuous(limits=c(0,15)) +
#coord_cartesian(xlim = c(5, 10))  +
xlab("Number of previous trials where\nmatcher responded") +
ylab("Trial time (ms)") +
theme(strip.background = element_blank(),
strip.text.x = element_blank())
pdf("../../results/graphs/CumulativeMatcherTurns_Efficiency.pdf",
width=4,height=4)
x + #xlim(0,10) +
geom_ribbon(aes(ymin=ci.low,ymax=ci.high),alpha = 0.15) +
scale_x_continuous(limits=c(0,15)) +
#coord_cartesian(xlim = c(5, 10))  +
xlab("Number of previous trials where\nmatcher responded") +
ylab("Trial time (ms)") +
theme(strip.background = element_blank(),
strip.text.x = element_blank())
dev.off()
x + #xlim(0,10) +
geom_ribbon(aes(ymin=ci.low,ymax=ci.high),alpha = 0.15) +
scale_x_continuous(limits=c(0,15)) +
#coord_cartesian(xlim = c(5, 10))  +
xlab("Number of previous trials where\nmatcher responded") +
ylab("Trial time (ms)") +
theme(strip.background = element_blank())
x + #xlim(0,10) +
geom_ribbon(aes(ymin=ci.low,ymax=ci.high),alpha = 0.15) +
scale_x_continuous(limits=c(0,15)) +
#coord_cartesian(xlim = c(5, 10))  +
xlab("Number of previous trials where\nmatcher responded") +
ylab("Trial time (ms)") +
theme(strip.background = element_blank(),
strip.text.x = element_text(""))
x + #xlim(0,10) +
geom_ribbon(aes(ymin=ci.low,ymax=ci.high),alpha = 0.15) +
scale_x_continuous(limits=c(0,15)) +
#coord_cartesian(xlim = c(5, 10))  +
xlab("Number of previous trials where\nmatcher responded") +
ylab("Trial time (ms)") +
theme(strip.background = element_blank(),
strip.text.x = element_blank())
?element_text
text_grob
?text_grob
x + #xlim(0,10) +
geom_ribbon(aes(ymin=ci.low,ymax=ci.high),alpha = 0.15) +
scale_x_continuous(limits=c(0,15)) +
#coord_cartesian(xlim = c(5, 10))  +
xlab("Number of previous trials where\nmatcher responded") +
ylab("Trial time (ms)") +
theme(strip.background = element_blank(),
strip.text.x = textGrob(""))
?theme
x + #xlim(0,10) +
geom_ribbon(aes(ymin=ci.low,ymax=ci.high),alpha = 0.15) +
scale_x_continuous(limits=c(0,15)) +
#coord_cartesian(xlim = c(5, 10))  +
xlab("Number of previous trials where\nmatcher responded") +
ylab("Trial time (ms)") +
theme(strip.background = element_blank(),
strip.text.x = element_text(colour = 'white'))
pdf("../../results/graphs/CumulativeMatcherTurns_Efficiency.pdf",
width=4,height=4)
x + #xlim(0,10) +
geom_ribbon(aes(ymin=ci.low,ymax=ci.high),alpha = 0.15) +
scale_x_continuous(limits=c(0,15)) +
#coord_cartesian(xlim = c(5, 10))  +
xlab("Number of previous trials where\nmatcher responded") +
ylab("Trial time (ms)") +
theme(strip.background = element_blank(),
strip.text.x = element_text(colour = 'white'))
dev.off()
dev.off()
dev.off()
pdf("../../results/graphs/CumulativeMatcherTurns_Efficiency.pdf",
width=4,height=4)
x + #xlim(0,10) +
geom_ribbon(aes(ymin=ci.low,ymax=ci.high),alpha = 0.15) +
scale_x_continuous(limits=c(0,15)) +
#coord_cartesian(xlim = c(5, 10))  +
xlab("Number of previous trials where\nmatcher responded") +
ylab("Trial time (ms)") +
theme(strip.background = element_blank(),
strip.text.x = element_text(colour = 'white'))
dev.off()
x + #xlim(0,10) +
geom_ribbon(aes(ymin=ci.low,ymax=ci.high),alpha = 0.15) +
scale_x_continuous(limits=c(0,15), breaks = c(0,3000,6000,9000,1200)) +
#coord_cartesian(xlim = c(5, 10))  +
xlab("Number of previous trials where\nmatcher responded") +
ylab("Trial time (ms)") +
theme(strip.background = element_blank(),
strip.text.x = element_text(colour = 'white'))
x + #xlim(0,10) +
geom_ribbon(aes(ymin=ci.low,ymax=ci.high),alpha = 0.15) +
scale_x_continuous(limits=c(0,15), breaks = c(0,3000,6000,9000,1200)) +
#coord_cartesian(xlim = c(5, 10))  +
xlab("Number of previous trials where\nmatcher responded") +
ylab("Trial time (ms)") +
theme(strip.background = element_blank(),
strip.text.x = element_text(colour = 'white'))
pdf("../../results/graphs/CumulativeMatcherTurns_Efficiency.pdf",
width=4,height=4)
x + #xlim(0,10) +
geom_ribbon(aes(ymin=ci.low,ymax=ci.high),alpha = 0.15) +
scale_x_continuous(limits=c(0,15)) +
scale_y_continuous(breaks = c(0,3000,6000,9000,1200)) +
#coord_cartesian(xlim = c(5, 10))  +
xlab("Number of previous trials where\nmatcher responded") +
ylab("Trial time (ms)") +
theme(strip.background = element_blank(),
strip.text.x = element_text(colour = 'white'))
dev.off()
x + #xlim(0,10) +
geom_ribbon(aes(ymin=ci.low,ymax=ci.high),alpha = 0.15) +
scale_x_continuous(limits=c(0,15)) +
scale_y_continuous(breaks = c(0,3000,6000,9000,1200)) +
#coord_cartesian(xlim = c(5, 10))  +
xlab("Number of previous trials where\nmatcher responded") +
ylab("Trial time (ms)") +
theme(strip.background = element_blank(),
strip.text.x = element_text(colour = 'white'))
x + #xlim(0,10) +
geom_ribbon(aes(ymin=ci.low,ymax=ci.high),alpha = 0.15) +
scale_x_continuous(limits=c(0,15)) +
scale_y_continuous(breaks = c(0,3000,6000,9000,12000)) +
#coord_cartesian(xlim = c(5, 10))  +
xlab("Number of previous trials where\nmatcher responded") +
ylab("Trial time (ms)") +
theme(strip.background = element_blank(),
strip.text.x = element_text(colour = 'white'))
pdf("../../results/graphs/CumulativeMatcherTurns_Efficiency.pdf",
width=4,height=4)
x + #xlim(0,10) +
geom_ribbon(aes(ymin=ci.low,ymax=ci.high),alpha = 0.15) +
scale_x_continuous(limits=c(0,15)) +
scale_y_continuous(breaks = c(0,3000,6000,9000,12000)) +
#coord_cartesian(xlim = c(5, 10))  +
xlab("Number of previous trials where\nmatcher responded") +
ylab("Trial time (ms)") +
theme(strip.background = element_blank(),
strip.text.x = element_text(colour = 'white'))
dev.off()
table(d$matcherResponds,d$condition)
table(d$matcherResponds,d$modalityCondition)
---
title: "Modality effects in a signalling game"
output: pdf_document
knit: (function(inputFile, encoding) { rmarkdown::render(inputFile, encoding = encoding, output_file = file.path(dirname(inputFile), "../../results/MainResults_Efficiency.pdf")) })
---
# Intro
This script uses data compiled by *analyseData.R*.
## Load libraries
```{r warning=FALSE, message=FALSE}
library(lme4)
library(sjPlot)
library(ggplot2)
library(lattice)
library(influence.ME)
```
```{r echo=F}
try(setwd("~/Documents/MPI/ViniciusMultimodal/multimodalCommunicationGame/experiment/analysis/R/"))
```
## Load data
```{r}
d = read.csv("../../data/FinalSignalData.csv")
```
Variable for length of first T1
```{r}
T1L = tapply(d[d$turnType=="T1",]$turnLength,
d[d$turnType=="T1",]$trialString, head, n=1)
d$T1Length = T1L[d$trialString]
d$T1Length[is.na(d$T1Length)] = mean(d$T1Length,na.rm=T)
d$T1Length.log = log(d$T1Length)
d$T1Length.log = d$T1Length.log - mean(d$T1Length.log)
```
We don't need info on every signal in each turn, just the trial time.  Keep only 1st signal in each trial.
```{r}
d = d[!duplicated(d$trialString),]
```
# Descriptive stats
Here is a graph showing the distribution of trial lengths by conditions:
![The efficiency of trials in different conditions](../../results/graphs/Efficiency.pdf)
Average trial time for the whole experiment:
```{r}
mean(d$trialLength)
sd(d$trialLength)
```
The distribution of trial times is very skewed:
```{r}
hist(d$trialLength)
```
So we transform it using a log transform, then center the data.
```{r}
d$trialLength.log = log(d$trialLength)
meanLogTrialLength = mean(d$trialLength.log)
d$trialLength.log = d$trialLength.log - meanLogTrialLength
hist(d$trialLength.log)
```
Make a variable to represent proportion of games played:
```{r}
# Make a variable that represents the number of trials played
d$trialTotal = d$trial + (d$game * (max(d$trial)+1))
# Convert to proportion of games played, so that estimates reflect change per game.
d$trialTotal = d$trialTotal / 16
# Center the trialTotal variable so intercept reflects after the first game
d$trialTotal = d$trialTotal - 2
matcherResponds.cumulative.mean = mean(d$matcherResponds.cumulative)
d$matcherResponds.cumulative = d$matcherResponds.cumulative - matcherResponds.cumulative.mean
d$matcherResponds = factor(d$matcherResponds)
```
Make a variable for which stimuli the players experienced first.
```{r}
firstBlock = tapply(as.character(d$condition),d$dyadNumber,head,n=1)
d$firstBlock = as.factor(firstBlock[match(d$dyadNumber,names(firstBlock))])
```
Reorder some levels so that the intercept reflects the most frequent condition.
```{r}
d$incorrect = !d$correct
```
Variable for whether T1 was a multimodal signal.
```{r}
turnD = read.csv("../../data/Final_Turn_data.csv")
turnD = turnD[turnD$turnType=="T1",]
turnD = turnD[turnD$role == "Director",]
d$multimodal = turnD[match(d$trialString, turnD$trialString),]$turnModalityType == "multi"
d$multimodal[is.na(d$multimodal)] = F
```
table(d$matcherResponds,d$modalityCondition)
table(d$turnNumber,d$modalityCondition)
table(d$turnType,d$modalityCondition)
