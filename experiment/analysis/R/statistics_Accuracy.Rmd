---
title: "Modality effects in a signalling game: Accuracy"
output:
    pdf_document:
        includes:
            in_header: header.tex 
knit: (function(inputFile, encoding) { rmarkdown::render(inputFile, encoding = encoding, output_file = file.path(dirname(inputFile), "../../results/MainResults_Accuracy.pdf")) })
---

# Intro 

This script uses data compiled by *analyseData.R*.

## Load libraries

```{r warning=FALSE, message=FALSE}
library(lme4)
library(sjPlot)
library(ggplot2)
library(lattice)
library(influence.ME)
library(party)
library(dplyr)
```

```{r echo=F}
try(setwd("~/Documents/MPI/ViniciusMultimodal/multimodalCommunicationGame/experiment/analysis/R/"))
```

## Load data

```{r}
d = read.csv("../../data/FinalSignalData.csv")
```

Work out number of turns in each trial.

```{r}
# Number of turns in each trial
numTurns = tapply(d$turnString, d$trialString, 
                  function(X){length(unique(X))})
d$numberOfTurns = numTurns[d$trialString]
```

Variable for length of first T1

```{r}
T1L = tapply(d[d$turnType=="T1",]$turnLength,
             d[d$turnType=="T1",]$trialString, head, n=1)
d$T1Length = T1L[d$trialString]
d$T1Length[is.na(d$T1Length)] = mean(d$T1Length,na.rm=T)
d$T1Length.log = log(d$T1Length)
d$T1Length.log = d$T1Length.log - mean(d$T1Length.log)
```

Did matcher respond?

```{r}
matcherResponds = tapply(d$turnType, d$trialString, function(X){
  any(X %in% c("T2","T4","T6","T8",'T10'))
})
d$matcherResponds = matcherResponds[d$trialString]
```

We don't need info on every signal in each turn, just the trial time.  Keep only 1st signal in each trial.

```{r}
d = d[!duplicated(d$trialString),]
```



# Descriptive stats

Here is a graph showing the distribution of accuracy by conditions:

```{r}
summary = d %>% 
  group_by(condition, modalityCondition,game) %>% 
  summarise(Accuracy=mean(correct),
            sd=sd(correct),
            ci.w =           qnorm(0.95)*sd/sqrt(length(correct)),
            upper=Accuracy+ci.w,
            lower = Accuracy-ci.w)
summary$game = summary$game +1

summary$modalityCondition =
  factor(summary$modalityCondition,
         levels = c("visual",'multi','vocal'),
         labels=c("Gestural","Multimodal","Vocal"))

#ggplot(d, aes(x=trialTotal, y=as.numeric(correct),colour=modalityCondition)) +
#  geom_smooth() + facet_grid(.~condition)

#ggplot(d, aes(x=trialTotal, y=as.numeric(correct),colour=condition)) +
#  geom_smooth() + #facet_grid(.~modalityCondition)

ggplot(summary, aes(x=game, y=Accuracy, group=condition, colour=modalityCondition)) + 
  geom_point() +
  geom_errorbar(aes(ymin=lower, ymax=upper)) +
  facet_grid(. ~ condition) +
  stat_summary(fun.y="mean", geom="line", aes(group=modalityCondition))

gx = ggplot(summary, aes(x=game, y=Accuracy, group=condition, colour=condition, shape=condition)) + 
  geom_point() +
  geom_errorbar(aes(ymin=lower, ymax=upper)) +
  facet_grid(. ~ modalityCondition) +
  stat_summary(fun.y="mean", geom="line", aes(group=condition)) +
  scale_colour_discrete(name="Stimuli") +
  scale_shape_discrete(name="Stimuli") +
  xlab("Game")
gx
pdf("../../results/graphs/Accuracy_gg.pdf",
    width = 5, height=3)
gx
dev.off()

gx1 = ggplot(summary, aes(x=game, y=Accuracy, group=condition, colour=modalityCondition)) + 
  geom_errorbar(aes(ymin=lower, ymax=upper), width=0.5) +
  facet_grid(. ~ condition) +
  stat_summary(fun.y="mean", geom="line", aes(group=modalityCondition)) +
    geom_point() +
  scale_colour_discrete(name="Condition") +
  ggtitle("Accuracy") +
  xlab("Game")

gx1
pdf("../../results/graphs/Accuracy_gg_alt.pdf",
    width = 5, height=3)
gx1
dev.off()
```

\newpage

Make a variable to represent proportion of games played:

```{r}
# Make a variable that represents the number of trials played
d$trialTotal = d$trial + (d$game * (max(d$trial)+1))
# Convert to proportion of games played, so that estimates reflect change per game.
d$trialTotal = d$trialTotal / 16
# Center the trialTotal variable so intercept reflects after the first game
d$trialTotal = d$trialTotal

```

Average accuracy per dyad:

```{r}
av.acc = tapply(d$correct, d$dyadNumber, function(X){sum(X)/length(X)})
mean(av.acc)
```



Make a variable for which stimuli the players experienced first.

```{r}
firstBlock = tapply(as.character(d$condition),d$dyadNumber,head,n=1)
d$firstBlock = as.factor(firstBlock[match(d$dyadNumber,names(firstBlock))])
```

Variable to indicate whether T1 is multimodal.

```{r}
turnD = read.csv("../../data/Final_Turn_data.csv")
turnD = turnD[turnD$turnType=="T1",]
turnD = turnD[turnD$role == "Director",]
d$multimodal = turnD[match(d$trialString, turnD$trialString),]$turnModalityType == "multi"
d$multimodal[is.na(d$multimodal)] = F
```

Make a variable to represent proportion of games played:

```{r}
# Make a variable that represents the number of trials played
d$trialTotal = d$trial + (d$game * (max(d$trial)+1))
# Convert to proportion of games played, so that estimates reflect change per game.
d$trialTotal = d$trialTotal / 16
# Center the trialTotal variable so intercept reflects after the first game
d$trialTotal = d$trialTotal - 2
```

Transformed trial time.

```{r}
d$trialLength.log = log(d$trialLength)
meanLogTrialLength = mean(d$trialLength.log)
d$trialLength.log = d$trialLength.log - meanLogTrialLength 
```


Get an idea of the structure of the data from a binary tree:
```{r}
cx = ctree(correct ~ modalityCondition + condition +
            trialTotal +
            trialLength +
            matcherResponds +
            matcherResponds +
            T1Length +
            multimodal+
            firstBlock,
          data=d)
```
\blandscape
```{r fig.width=20, fig.height=8}
plot(cx, terminal_panel=node_barplot(cx))
```
\elandscape


\newpage

# Mixed models

There are celing effects in the data, which reduces variance and makes model convergence difficult.  Experimentation revealed that random effects other than random intercepts for dyad and item lead to non-convergence.

The final models do not converge within standard tolerances, but the convergence is acceptable.

```{r models, cache=TRUE}
# No fixed effects

gc = glmerControl(optimizer = "bobyqa" ,optCtrl = list(maxfun=50000))

m0 =  glmer(correct ~ 1 +
            (1 |dyadNumber) +
            (1 |itemId) ,
          data=d, family=binomial,
          control = gc)

game = glmer(correct ~ 1 + 
            trialTotal +
            (1 |dyadNumber) +
            (1 |itemId) ,
          data=d, family=binomial,
          control = gc)

trialL = glmer(correct ~ 1 +
            trialTotal +
            trialLength.log+
            (1 |dyadNumber) +
            (1 |itemId) ,
          data=d, family=binomial,
          control = gc)

t1L = glmer(correct ~ 1 + 
            trialTotal +
            trialLength.log +
            T1Length.log +
            (1 |dyadNumber) +
            (1 |itemId) ,
          data=d, family=binomial,
          control = gc)

multi = glmer(correct ~ 1 +
            trialTotal +
            trialLength.log +
            T1Length.log +
            multimodal+
            (1 |dyadNumber) +
            (1 |itemId) ,
          data=d, family=binomial,
          control = gc)


mtchTrn = glmer(correct ~ 1 +
            trialTotal +
            trialLength.log +
            T1Length.log +
            multimodal+
            matcherResponds +
            (1 |dyadNumber) +
            (1 |itemId) ,
          data=d, family=binomial,
          control = gc)

tMtchTr = glmer(correct ~ 1 +
            trialTotal +
            trialLength.log +
            T1Length.log +
            multimodal+
            matcherResponds +
            matcherResponds.cumulative +
            (1 |dyadNumber) +
            (1 |itemId) ,
          data=d, family=binomial,
          control = gc)

con = glmer(correct ~ 1 + condition +
            trialTotal +
            trialLength.log +
            T1Length.log +
            multimodal+
            matcherResponds +
            matcherResponds.cumulative +
            (1 |dyadNumber) +
            (1 |itemId) ,
          data=d, family=binomial,
          control = gc)

mod = glmer(correct ~ 1 + modalityCondition + condition +
            trialTotal +
            trialLength.log +
            T1Length.log +
            multimodal+
            matcherResponds +
            matcherResponds.cumulative +
            (1 |dyadNumber) +
            (1 |itemId) ,
          data=d, family=binomial,
          control = gc)

modXcon = glmer(correct ~ 1 + modalityCondition * condition +
            trialTotal +
            trialLength.log +
            T1Length.log +
            multimodal+
            matcherResponds +
            matcherResponds.cumulative +
            (1 |dyadNumber) +
            (1 |itemId) ,
          data=d, family=binomial,
          control = gc)

trialLXmo = glmer(correct ~ 1 + modalityCondition * condition +
            trialTotal +
            trialLength.log * modalityCondition+
            T1Length.log +
            multimodal+
            matcherResponds +
            matcherResponds.cumulative +
            (1 |dyadNumber) +
            (1 |itemId) ,
          data=d, family=binomial,
          control = gc)

t1LXmo = glmer(correct ~ 1 + modalityCondition * condition +
            trialTotal +
            trialLength.log * modalityCondition+
            T1Length.log *modalityCondition +
            multimodal+
            matcherResponds +
            matcherResponds.cumulative +
            (1 |dyadNumber) +
            (1 |itemId) ,
          data=d, family=binomial,
          control = gc)

tMaTXmo = glmer(correct ~ 1 + modalityCondition * condition +
            trialTotal +
            trialLength.log * modalityCondition+
            T1Length.log *modalityCondition +
            multimodal+
            matcherResponds +
            matcherResponds.cumulative +
              matcherResponds.cumulative:modalityCondition +
            (1 |dyadNumber) +
            (1 |itemId) ,
          data=d, family=binomial,
          control = gc)


block = glmer(correct ~ 1 + modalityCondition * condition +
            trialTotal +
            trialLength.log * modalityCondition+
            T1Length.log *modalityCondition +
            multimodal+
            matcherResponds +
            matcherResponds.cumulative +
              matcherResponds.cumulative:modalityCondition +
            matcherResponds +
            firstBlock +
            (1 |dyadNumber) +
            (1 |itemId) ,
          data=d, family=binomial,
          control = gc)

```

\newpage

# Results

Compare the fit of the models:

```{r anova}
modelComparison = anova(m0,con,mod,modXcon, 
                        game, trialL,trialLXmo,
                        t1L, t1LXmo, mtchTrn, tMtchTr,tMaTXmo,
                        multi, block)
x = capture.output(modelComparison)
x[!grepl(": ",x)]
```

Pick final model for estimates with only significant variables:

```{r}
finalModel = glmer(correct ~ 1 + 
            modalityCondition * condition +
            trialTotal +
            trialLength.log +
            matcherResponds.cumulative +
            (1 |dyadNumber) +
            (1 |itemId) ,
          data=d, family=binomial,
          control = gc)
```

Model estimates:

```{r}
summary(finalModel)
# number of correctly categorised trials
sum((predict(finalModel)>0) == d$correct)/nrow(d)
```


## Plot the fixed effects

Relabel the effects:

```{r}

feLabels = matrix(c(
"(Intercept)"             ,"Intercept"      , NA,                         
"modalityConditionvisual" ,"Visual modality", "mod",
"modalityConditionvocal"  , "Acoustic modality", "mod",
"conditionVisual" , "Visual stimuli","con",
"trialTotal"             , "Game","game",
"modalityConditionvisual:conditionVisual"  , "Visual modality:Visual stimuli", "modXcon",
"modalityConditionvocal:conditionVisual" , "Acoustic modality:Visual stimuli","modXcon",
"firstBlockVisual","Visual stims first","block",
"trialLength.log","Trial length","trialL",
"modalityConditionvisual:trialLength.log","Visual modality:Trial length",'trialLXmo',
"modalityConditionvocal:trialLength.log","Acoustic modality:Trial length",'trialLXmo',
"multimodalTRUE","Multimodal T1","multi",
"trialLength.log",'Trial Length','trialL',
"T1Length.log","T1 length","t1L",
"modalityConditionvisual:T1Length.log","T1 length:Visual modality","t1LXmo",
"modalityConditionvocal:T1Length.log","T1 length:Acoustic modality","t1LXmo",
"matcherRespondsTRUE","Matcher Responds",'mtchTrn',
"matcherResponds.cumulative","Total interaction","tMtchTr",
"modalityConditionvisual:matcherResponds.cumulative","Total interaction:Visual Modality","tMaTXmo",
"modalityConditionvocal:matcherResponds.cumulative","Total interaction:Vocal Modality","tMaTXmo"
), ncol=3, byrow = T)
feLabels1 = as.vector(feLabels[match(names(fixef(finalModel)),feLabels[,1]),1])
feLabels2 = as.vector(feLabels[match(names(fixef(finalModel)),feLabels[,1]),2])
feModel = as.vector(feLabels[match(names(fixef(finalModel)),feLabels[,1]),3])

sig = modelComparison$`Pr(>Chisq)`
names(sig) = rownames(modelComparison)

sig.data = data.frame(
  estimate = fixef(finalModel),
  y=1:length(fixef(finalModel)),
  sig=sig[feModel])
sig.data$fade = sig.data$sig > 0.05
```

Plot the strength of the fixed effects:


```{r}
x = sjp.glmer(finalModel, 'fe', 
         show.intercept = T,
         sort.est=NULL,
         axis.labels = feLabels2[2:length(feLabels2)],
         axis.title="Odds of correct selection",
         geom.colors = c(1,1),
         show.values = F,
         show.p = F,
         fade.ns = T,
         string.interc="Intercept",
         prnt.plot = F) 

x$plot.list[[1]]$data$fade = sig.data$fade

x$plot.list[[1]] 
```

Table of results

```{r}
x = as.data.frame(summary(finalModel)$coef)
mc = as.data.frame(modelComparison)
write.csv(cbind(x,mc[feModel,]), "../../results/tables/Accuracy_FixedEffects.csv")
```


\newpage

## Random effects

```{r}
sjp.glmer(finalModel,'re', sort.est ="sort.all", 
          facet.grid = F,
          geom.colors= c(1,1))
```

qq-plots of random effects

```{r}
sjp.glmer(finalModel, type = "re.qq")
```


\newpage

## Plots

```{r eval=F}
gx = sjp.glmer(finalModel, 'eff', vars=c("matcherResponds.cumulative"), 
               title = '', prnt.plot = F,
               show.ci=T, facet.grid = F)

pdf("../../results/graphs/CumulativeMatcherTurns.pdf",
    width=4,height=4)
gx$plot + 
  xlab("Number of previous trials where\nmatcher responded") + 
  ylab("Probability of correct choice") + 
  #scale_x_continuous(breaks = c(0,5,10,15)) + 
  coord_cartesian(xlim=c(0,15)) 
dev.off()
```

```{r eval=F, echo=F}
sjp.glmer(finalModel, 'eff',show.ci=T, facet.grid = F)
```

```{r}
sjp.int(finalModel,'eff', show.ci = T)
```






