---
title: "Modality effects in a signalling game: Efficiency"
output: 
  pdf_document:
    toc: true
knit: (function(inputFile, encoding) { rmarkdown::render(inputFile, encoding = encoding, output_file = file.path(dirname(inputFile), "../../results/MainResults_Efficiency.pdf")) })
---

# Intro 

The main data used in this analysis comes from `../../data/FinalSignalData.csv` (compiled by  `analyseData.R`).  Each row represents one signal, but this script only keeps one signal per trial, and the rest of the analysis is on the trial-by-trial level.  The variables in the data are as follows (some are calculated in the script below):

-  X: ID
-  filename: Filename of the ELAN file
-  dyadNumber: ID of the participant dyad
-  condition: Stimuli type (Auditory or Visual)
-  game: Game number (0-3)
-  trial: Trial number (0-15)
-  target: Target stimuli shown to the director
-  choice: Meaning chosen by the matcher
-  correct: True if the matcher's choice is correct
-  trialStart, trialEnd, trialLength: Start, end and length of trial in milliseconds
-  trialValue:  A unique string that represents data from the trial.  Numbers in the curly brackets represent the choices given to the matcher
-  startOfNextTrial: Timestamp for next trial, used in processing the data.
-  turnStart, turnEnd, turnLength: the start, end and length of the turn in milliseconds.
-  signalStart, signalEnd, signalLength: the start, end and length of the signal.
-  signalType:  Annotation value in ELAN, not meaningful
-  tiralString: Unique string to identify trial
-  modalityCondition:  The condition for the dyad (multi= multimodal, visual=gesture only, vocal=vocal only)
-  playerId:  Unique ID for the participant producing the signal 
-  itemId:  Unique ID for the target stimulus
-  turnString:  Unque ID for the turn
-  matcherResponds:  Does matcher take a turn in this trial?
-  matcherResponds.cumulative: The (scaled) number of previous trials that a has responded.
-  T1Length, T1Length.log:  Length and log length of the director's first turn.
-  trialTotal: Number of trials played so far, scaled (and centered) to represent number of games played.
-  firstBlock:  Block order
-  incorrect:  Was the matcher's choice incorrect?
-  multimodal:  Was the director's first turn multimodal?


## Load libraries

```{r warning=FALSE, message=FALSE}
library(lme4)
library(sjPlot)
library(ggplot2)
library(lattice)
#library(influence.ME)
library(dplyr)
```

The sjPlot library was updated during this investigation, removing various functions. They are reinstated here:

```{r}
sjp.lmer = plot_model
```


```{r echo=F}
try(setwd("~/Documents/MPI/ViniciusMultimodal/multimodalCommunicationGame/experiment/analysis/R/"))
```

## Load data

```{r}
d = read.csv("../../data/FinalSignalData.csv")
```

Variable for length of first T1

```{r}
T1L = tapply(d[d$turnType=="T1",]$turnLength,
             d[d$turnType=="T1",]$trialString, head, n=1)
d$T1Length = T1L[d$trialString]
d$T1Length[is.na(d$T1Length)] = mean(d$T1Length,na.rm=T)
d$T1Length.log = log(d$T1Length)
d$T1Length.log = d$T1Length.log - mean(d$T1Length.log)
```

We don't need info on every signal in each turn, just the trial time.  Keep only 1st signal in each trial.

```{r}
d = d[!duplicated(d$trialString),]
```


# Descriptive stats

Make a variable to represent proportion of games played:

```{r}
# Make a variable that represents the number of trials played
d$trialTotal = d$trial + (d$game * (max(d$trial)+1))
# Convert to proportion of games played, so that estimates reflect change per game.
d$trialTotal = d$trialTotal / 16
```

Here is a graph showing the distribution of trial lengths by conditions:

```{r}
summary = d %>% 
  group_by(condition, modalityCondition,game) %>% 
  summarise(Efficiency=mean(trialLength),
            sd=sd(trialLength),
            ci.w =           qnorm(0.95)*sd/sqrt(length(trialLength)),
            upper=Efficiency+ci.w,
            lower = Efficiency-ci.w)
summary$game = summary$game +1

summary$modalityCondition =
  factor(summary$modalityCondition,
         levels = c("visual",'multi','vocal'),
         labels=c("Gestural","Multimodal","Vocal"))

ggplot(d, aes(x=trialTotal, y=trialLength,colour=modalityCondition)) +
  geom_smooth() + facet_grid(.~condition)

ggplot(d, aes(x=trialTotal, y=trialLength,colour=condition)) +
  geom_smooth() + facet_grid(.~modalityCondition)

pd = position_dodge(width=0.5)
gx1 = ggplot(summary, aes(x=game, y=Efficiency, group=condition, colour=modalityCondition)) + 
  geom_errorbar(aes(ymin=lower, ymax=upper,group=modalityCondition), width=0.5,position=pd) +
  facet_grid(. ~ condition) +
  stat_summary(fun.y="mean", geom="line", aes(group=modalityCondition),position=pd) +
    geom_point(aes(group=modalityCondition,shape=modalityCondition),position=pd) +
  scale_colour_brewer(palette="Set2", name="Condition") +
  scale_shape(name="Condition") +
  theme(panel.grid.major.x = element_blank()) +
  ggtitle("Efficiency") +
  xlab("Game") +
  ylab("Trial length (ms)")

gx1
pdf("../../results/graphs/Efficiency_gg.pdf",
    width = 5, height=3)
gx1
dev.off()

gx2 = ggplot(summary, aes(x=game, y=Efficiency, group=condition, colour=condition, shape=condition)) + 
  geom_errorbar(aes(ymin=lower, ymax=upper), width=0.5) +
  facet_grid(. ~ modalityCondition) +
  stat_summary(fun.y="mean", geom="line", aes(group=condition)) +
    geom_point() +
  scale_colour_discrete(name="Stimuli") +
  scale_shape_discrete(name="Stimuli") +
  xlab("Game")

gx2
pdf("../../results/graphs/Efficiency_gg_alt.pdf",
    width = 5, height=3)
gx2
dev.off()
```

![The efficiency of trials in different conditions](../../results/graphs/Efficiency.pdf)

Average trial time for the whole experiment:

```{r}
mean(d$trialLength)
sd(d$trialLength)
```



The distribution of trial times is very skewed:

```{r}
hist(d$trialLength)
```

So we transform it using a log transform, then center the data.

```{r}
d$trialLength.log = log(d$trialLength)
meanLogTrialLength = mean(d$trialLength.log)
d$trialLength.log = d$trialLength.log - meanLogTrialLength 
hist(d$trialLength.log)
```

```{r}
# Center the trialTotal variable so intercept reflects after the first game
d$trialTotal = d$trialTotal - 2

matcherResponds.cumulative.mean = mean(d$matcherResponds.cumulative)

d$matcherResponds.cumulative = d$matcherResponds.cumulative - matcherResponds.cumulative.mean

d$matcherResponds = factor(d$matcherResponds)

```

Make a variable for which stimuli the players experienced first.

```{r}
firstBlock = tapply(as.character(d$condition),d$dyadNumber,head,n=1)
d$firstBlock = as.factor(firstBlock[match(d$dyadNumber,names(firstBlock))])
```


Reorder some levels so that the intercept reflects the most frequent condition.

```{r}
d$incorrect = !d$correct
```

Variable for whether T1 was a multimodal signal.

```{r}

turnD = read.csv("../../data/Final_Turn_data.csv")
turnD = turnD[turnD$turnType=="T1",]
turnD = turnD[turnD$role == "Director",]
d$multimodal = turnD[match(d$trialString, turnD$trialString),]$turnModalityType == "multi"
d$multimodal[is.na(d$multimodal)] = F

```

\newpage

# Mixed models

Make a series of models with random effects for dyad, director (nested within dyad) and item.

Not all random slopes are appropriate.  For example, items are used in only one stimulus condition, so a random slope for condition by item is not appropriate.  Similarly, each dyad only plays in one modality condition.

It is reasonable to have a random slope for trial by dyad, but this caused unreliable model convergence, so is not included.

The final random slopes were for condition and incorrectness by dyad/player, and modality condition by item.

```{r models, cache=TRUE}
# lme4 version 1.1-21 introduces different default optimisers
# Switch back to original:
ctrl = lmerControl(optimizer = "bobyqa")
# No fixed effects
m0 =  lmer(trialLength.log ~ 1 + 
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = FALSE,control = ctrl)

```

Now we add a series of possible confounding factors such as whether the matcher responds.  We add the main experimental factors at the end to ensure that they're really contributing to the model over and above the confounds.

```{r models2, cache=FALSE}

# Add effect of trial

game = lmer(trialLength.log ~ 1 + 
            trialTotal + 
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = FALSE,control = ctrl)

# Add the quadratic effect of trial
gamQuad = lmer(trialLength.log ~ 1 + 
            trialTotal + I(trialTotal^2) +
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = FALSE,control = ctrl)

# Add number of matcher turns
mtchTrn = lmer(trialLength.log ~ 1 +
                trialTotal + I(trialTotal^2) +
                matcherResponds +
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = FALSE,control = ctrl)

tMtchTr = lmer(trialLength.log ~ 1 +
                trialTotal + I(trialTotal^2) +
                matcherResponds +
                matcherResponds.cumulative +
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = FALSE,control = ctrl)

# Add whether the response was incorrect
incor = lmer(trialLength.log ~ 1 + 
            trialTotal + I(trialTotal^2) +
            matcherResponds + 
            matcherResponds.cumulative +  
            incorrect +
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = FALSE,control = ctrl)
```


```{r models3, cache=TRUE}
# Add multimodal signal

multim = lmer(trialLength.log ~ 1 + 
            trialTotal + I(trialTotal^2) +
            matcherResponds +
            matcherResponds.cumulative + 
            incorrect + 
            multimodal +
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = FALSE,control = ctrl)
```


```{r models5, cache=T}
# Add modality condition
modality =  lmer(trialLength.log ~ 1 + modalityCondition + 
            trialTotal + I(trialTotal^2) +
            matcherResponds + 
            matcherResponds.cumulative + 
            incorrect + 
            multimodal +
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = FALSE,control = ctrl)
# Add stimulus condition
cond = lmer(trialLength.log ~ 1 + modalityCondition + condition + 
            trialTotal + I(trialTotal^2) +
            matcherResponds + 
            matcherResponds.cumulative + 
            incorrect + 
            multimodal +
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = FALSE,control = ctrl)

# Add interaction between modality and stimulus condition
modXcond = lmer(trialLength.log ~ 1 + modalityCondition*condition +
           trialTotal + I(trialTotal^2) +
            matcherResponds + 
            matcherResponds.cumulative + 
            incorrect + 
            multimodal +
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = FALSE,control = ctrl)
```

```{r models6, cache=T}
# Add interaction between condition and trial
conXgame = lmer(trialLength.log ~ 1 + modalityCondition*condition +
            trialTotal + I(trialTotal^2) +
              condition:trialTotal +
            matcherResponds + 
            matcherResponds.cumulative + 
            incorrect + 
            multimodal +
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = FALSE,control = ctrl)
# Add interaction between modality and trial
modXgame = lmer(trialLength.log ~ 1 + modalityCondition*condition +
             trialTotal + I(trialTotal^2) +
              condition:trialTotal + modalityCondition:trialTotal +
            matcherResponds + 
            matcherResponds.cumulative + 
            incorrect + 
            multimodal +
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = FALSE,control = ctrl)

# Add 3-way interaction
moXcoXga =  lmer(trialLength.log ~ 1 + modalityCondition*condition*trialTotal +
             I(trialTotal^2) +
            matcherResponds + 
            incorrect + 
            multimodal +
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = FALSE,control = ctrl)
```

Interactions

```{r models8, cache=T}
# interaction between turns and modality
nTurnXmo = lmer(trialLength.log ~ 1 + modalityCondition*condition*trialTotal +
             I(trialTotal^2) +
            matcherResponds + matcherResponds:modalityCondition +
            matcherResponds.cumulative + 
            incorrect + 
            multimodal +
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = FALSE,control = ctrl)

nTurnXco = lmer(trialLength.log ~ 1 + modalityCondition*condition*trialTotal +
             I(trialTotal^2) +
            matcherResponds + matcherResponds:modalityCondition +
            matcherResponds:condition +
            matcherResponds.cumulative + 
            incorrect + 
            multimodal +
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = FALSE,control = ctrl)

# Turn x modality x condtion
# Note that the acousitc modality had hardly any matcher turns, 
# so the factor is dropped

tuXmoXco = lmer(trialLength.log ~ 1 + modalityCondition*condition*trialTotal +
             I(trialTotal^2) +
            matcherResponds*modalityCondition*condition +
            matcherResponds.cumulative + 
            incorrect + 
            multimodal +
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = FALSE,control = ctrl)

# Add the interaction between modality and incorrectness
moXincor =   lmer(trialLength.log ~ 1 + modalityCondition*condition*trialTotal +
             I(trialTotal^2) +
            matcherResponds*modalityCondition*condition +
            matcherResponds.cumulative + 
            incorrect + incorrect:modalityCondition +
            multimodal +
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = FALSE,control = ctrl)
# Add the interaction between condition and incorrectness
coXincor =  lmer(trialLength.log ~ 1 + modalityCondition*condition*trialTotal +
             I(trialTotal^2) +
            matcherResponds*modalityCondition*condition +
            matcherResponds.cumulative + 
            incorrect + incorrect:modalityCondition + incorrect:condition +
            multimodal +
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = FALSE,control = ctrl)
# Add the three-way interaction between condition, modality and incorrectness
coXmoXin = lmer(trialLength.log ~ 1 + modalityCondition*condition*trialTotal +
             I(trialTotal^2) +
            matcherResponds*modalityCondition*condition +
            matcherResponds.cumulative + 
            incorrect *modalityCondition*condition +
            multimodal +
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = FALSE,control = ctrl)

```


```{r models4, cache=TRUE}
# Interaction between multimodality and condition
multiXco = lmer(trialLength.log ~ 1 + modalityCondition*condition*trialTotal +
             I(trialTotal^2) +
            matcherResponds*modalityCondition*condition +
            matcherResponds.cumulative + 
            incorrect *modalityCondition*condition +
            multimodal + multimodal:condition + 
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = FALSE,control = ctrl)

# Add interaction between quadratic effect of trial and modality
modXgamQ =  lmer(trialLength.log ~ 1 + modalityCondition*condition*trialTotal +
             I(trialTotal^2) +(modalityCondition:I(trialTotal^2)) +
            matcherResponds*modalityCondition*condition +
            matcherResponds.cumulative +
            incorrect *modalityCondition*condition +
            multimodal + multimodal:condition + 
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = FALSE,control = ctrl)



```


Interactions with matcher turns

```{r models 3.5, cache=TRUE}
tMaTxMod = lmer(trialLength.log ~ 1 + modalityCondition*condition*trialTotal +
             I(trialTotal^2) +(modalityCondition:I(trialTotal^2)) +
            matcherResponds*modalityCondition*condition +
            matcherResponds.cumulative + 
              matcherResponds.cumulative:modalityCondition +
            incorrect *modalityCondition*condition +
            multimodal + multimodal:condition + 
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = FALSE,control = ctrl)
```

Check block has no effect

```{r}
# Add block order
block =  lmer(trialLength.log ~ 1 + modalityCondition*condition*trialTotal +
             I(trialTotal^2) +(modalityCondition:I(trialTotal^2)) +
            matcherResponds*modalityCondition*condition +
            matcherResponds.cumulative + 
              matcherResponds.cumulative:modalityCondition +
            incorrect *modalityCondition*condition +
            multimodal + multimodal:condition + 
            matcherResponds +
            firstBlock +
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = TRUE, control = ctrl)
# Last model is REML to get estimates

# Add interaction between block order and modality
blocXmod = lmer(trialLength.log ~ 1 + modalityCondition*condition*trialTotal +
             I(trialTotal^2) +(modalityCondition:I(trialTotal^2)) +
            matcherResponds*modalityCondition*condition +
            matcherResponds.cumulative + 
              matcherResponds.cumulative:modalityCondition +
            incorrect *modalityCondition*condition +
            multimodal + multimodal:condition + 
            matcherResponds +
            firstBlock*modalityCondition +
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = TRUE)   
```


\newpage

# Results

Compare the fit of the models:

```{r anova}
modelComparison = anova(m0,modality,cond,game,modXcond,conXgame, modXgame,
      moXcoXga,mtchTrn,tMtchTr,tMaTxMod,nTurnXmo,nTurnXco,tuXmoXco,
      incor,moXincor,coXincor,coXmoXin,
      multim,multiXco,
      gamQuad,modXgamQ,
      block, blocXmod)
attributes(modelComparison)$heading = ""
modelComparison
```

Pick final model for estimates:

```{r}
finalModel = block
```

Final model estimates:

```{r}
summary(finalModel)
```


Check model predictions.  The model predictions are in the right range and direction, fitting linear quite well:

```{r}
plot(predict(blocXmod),d$trialLength.log, pch=16, col=rgb(0,0,0,0.4),
     ylim=c(-1.5,2),xlim=c(-1.5,2))
abline(a=0,b=1, col=2, lwd=2)
abline(h=0, col=2)
abline(v=0, col=2)

cor(predict(finalModel), d$trialLength.log)
```

The residuals are ok, though it tends to do worse at higher values.  This is expected from using the log scale.

```{r}
qqnorm(resid(blocXmod))
qqline(resid(blocXmod))
```


## Plot the fixed effects

Relabel the effects:

```{r}

feLabels = matrix(c(
"(Intercept)"             ,"Intercept"      , NA,                         
"modalityConditionvisual" ,"Visual modality", "modality",
"modalityConditionvocal"  , "Acoustic modality", "modality",
"conditionVisual" , "Visual stimuli","cond",
"trialTotal"             , "Game","game",
"modalityConditionvisual:conditionVisual"  , "Visual modality:Visual stimuli", "modXcond",
"modalityConditionvocal:conditionVisual" , "Acoustic modality:Visual stimuli","modXcond",
"modalityConditionvisual:trialTotal"    , "Visual modality:Game","modXgame",
"modalityConditionvocal:trialTotal"     , "Acoustic modality:Game", "modXgame",
"conditionVisual:trialTotal"             , "Visual stimuli:Game","conXgame",
"modalityConditionvisual:conditionVisual:trialTotal", "Visual modality:Visual stimuli:Game", "moXcoXga",
"modalityConditionvocal:conditionVisual:trialTotal", "Acoustic modality:Visual stimuli:Game", "moXcoXga",
"incorrectTRUE","Incorrect","incor",
"modalityConditionvisual:incorrectTRUE","Visual modality:Incorrect","moXincor",
"modalityConditionvocal:incorrectTRUE","Acoustic modality:Incorrect","moXincor",
"modalityConditionvisual:I(trialTotal^2)", "Visual modality:Game^2","modXgamQ",
"modalityConditionvocal:I(trialTotal^2)", "Acoustic modality:Game^2","modXgamQ",
"I(trialTotal^2)","Game^2","gamQuad",
"firstBlockVisual","Visual stims first","block",
"modalityConditionvisual:firstBlockVisual","Visual modality:Visual stim first","blocXmod",
"modalityConditionvocal:firstBlockVisual","Acoustic modality:Visual stim first","blocXmod",
"conditionVisual:incorrectTRUE","Visual stimuli:incorrect","coXincor",
"modalityConditionvisual:conditionVisual:incorrectTRUE","Visual modality:Visual stimuli:incorrect","coXmoXin",
"modalityConditionvocal:conditionVisual:incorrectTRUE","Acoustic modality:Visual stimuli:incorrect","coXmoXin",

"modalityConditionvisual:conditionVisual:numberOfTurns","VisualModality:Visual stim:NumTurns","tuXmoXco",
"modalityConditionvisual:conditionVisual:matcherRespondsTRUE","VisualModality:Visual stim:Matcher Responds","tuXmoXco",
"modalityConditionvocal:conditionVisual:numberOfTurns","Vocal Modality:Visual stim:NumTurns","tuXmoXco",
"modalityConditionvocal:conditionVisual:matcherRespondsTRUE","Vocal Modality:Visual stim:Matcher Responds","tuXmoXco",
"conditionVisual:numberOfTurns","Visual stim:NumTurns","nTurnXco",
"conditionVisual:matcherRespondsTRUE","Visual stim:Matcher Responds","nTurnXco",
"modalityConditionvisual:numberOfTurns","VisualModality:NumTurns","nTurnXmo",
"modalityConditionvisual:matcherRespondsTRUE","VisualModality:Matcher Responds","nTurnXmo",
"modalityConditionvocal:numberOfTurns","Vocal Modality:NumTurns","nTurnXmo",
"modalityConditionvocal:matcherRespondsTRUE","Vocal Modality:Matcher Responds","nTurnXmo",
"numberOfTurns","Number of turns","nTurns",
"multimodalTRUE","Multimodal T1","multim",
"conditionVisual:multimodalTRUE","VisualStim:MultimodalT1","multiXco",
"matcherRespondsTRUE","Matcher Responds",'mtchTrn',
"matcherResponds.cumulative","Total interaction","tMtchTr",
"modalityConditionvisual:matcherResponds.cumulative","Total interaction:Visual Modality","tMaTxMod",
"modalityConditionvocal:matcherResponds.cumulative","Total interaction:Vocal Modality","tMaTxMod"
), ncol=3, byrow = T)

feLabels2 = as.vector(feLabels[match(names(fixef(finalModel)),feLabels[,1]),2])
feModel = as.vector(feLabels[match(names(fixef(finalModel)),feLabels[,1]),3])

sig = modelComparison$`Pr(>Chisq)`
names(sig) = rownames(modelComparison)

sig.data = data.frame(estimate = fixef(finalModel),
                      y=1:length(fixef(finalModel)),
                      sig=sig[feModel])

cols= c("black",'red')
sig.data$pointCol = cols[1]
sig.data$pointCol[!is.na(sig.data$sig)] = 
  cols[1 + (sig.data$sig[!is.na(sig.data$sig)] < 0.05)]
# Mark marginal effects
#sig.data$pointCol[!is.na(sig.data$sig) & 
#                    sig.data$sig < 0.1 & 
#                    sig.data$sig >=0.05] = "orange"
  
sig.data$fade = sig.data$sig > 0.05
```

Plot the strength of the fixed effects:

```{r fixEf, warning=F}
x = get_model_data(finalModel, 'est')
x$label = feLabels2[2:length(feLabels2)]
x$col = c("sig","nonsig")[1+(x$p.value>=0.05)]
ggplot(x, aes(y=estimate,x=label,colour=col)) +
  geom_hline(yintercept = 0) +
  geom_point() +
  geom_errorbar(aes(ymin=x$conf.low,ymax=x$conf.high)) +
  coord_flip() +
  theme(legend.position = 'none')
```

\newpage

Attempt plot with axes in milliseconds.

```{r fixEfMilliseconds, warning=F}
convertEst = function(X){
  exp(meanLogTrialLength+X) - exp(meanLogTrialLength)
}

x$estimate = convertEst(x$estimate)
x$conf.low = convertEst(x$conf.low)
x$conf.high = convertEst(x$conf.high)

ggplot(x, aes(y=estimate,x=label,colour=col)) +
  geom_hline(yintercept = 0) +
  geom_point() +
  geom_errorbar(aes(ymin=x$conf.low,ymax=x$conf.high)) +
  theme(legend.position = 'none') +
  coord_flip(ylim = c(-5000,5000))

```

for every 10 trials where a matcher responded, subsequent trials were shorter by:

```{r}
noInteraction = convertEst(
  fixef(finalModel)["(Intercept)"]
)
tenResponses = convertEst(
  fixef(finalModel)["(Intercept)"] +
  (10 * fixef(finalModel)["matcherResponds.cumulative"])
)
noInteraction - tenResponses
```


\newpage

Table for paper

```{r}
outdata = x[,c("term","label","estimate","conf.low",'conf.high')]

outdata$estimate = base::round(outdata$estimate)
outdata$conf.low = base::round(outdata$conf.low)
outdata$conf.high = base::round(outdata$conf.high)

xd = as.data.frame(summary(finalModel)$coef)
outdata$wald.t = xd[match(outdata$term,rownames(xd)),'t value']

outdata = cbind(outdata,
      modelComparison[feModel[2:length(feModel)],c("logLik","Chisq","Pr(>Chisq)")])
outdata$estimate = paste(
  c("","+")[1+(outdata$estimate>0)],
  as.character(outdata$estimate),sep='')

outdata = outdata[,c("label","estimate","conf.low",
                     "conf.high","wald.t","Chisq",
                     "Pr(>Chisq)")]
finalRes = outdata
write.csv(finalRes,file="../../results/tables/Efficiency_FixedEffects.csv")
```


## Random effects

There is a reasonable amount of variaition in the random effects, suggesting that dyads and players differ.  This justifies the use of mixed effects modelling.

```{r ranEf}
dotplot(ranef(finalModel))
```


## Relevel factors to see other comparisons

```{r}
d2 = d
d2$condition = relevel(d2$condition,"Visual")
fm2 = update(finalModel, data=d2)
summary(fm2)
```

```{r}
d2 = d
d2$modalityCondition = relevel(d2$modalityCondition,"visual")
fm2 = update(finalModel, data=d2)
summary(fm2)
```


## Variance explained

Total variance explained by the model: Calculated by pseudo R squared method from the *MuMIn* package to calculate the variance explained by fixed effects and random effects in a model (Nakagawa & Schielzeth 2013). 

```{r}
MuMIn::r.squaredGLMM(finalModel)
```

Fixed effects explain `r signif(MuMIn::r.squaredGLMM(finalModel)[1],4)*100`% of the variance. Total varaince explained = `r signif(MuMIn::r.squaredGLMM(finalModel)[2],4)*100`%. (random effects = `r signif(diff(MuMIn::r.squaredGLMM(finalModel)[1:2]),4)*100`).

For each model in the bottom-up procedure, we then calculate the increase in variance explained. This is an estiamte of how much variance a particular variable accounts for.

```{r}
mList = list("m0"=m0,"mtchTrn"=mtchTrn,"modality"=modality,"cond"=cond,
"game"=game,"modXcond"=modXcond,"conXgame"=conXgame,"modXgame"=modXgame,
"moXcoXga"=moXcoXga,"tMtchTr"=tMtchTr,"tMaTxMod"=tMaTxMod,"nTurnXmo"=nTurnXmo,
"nTurnXco"=nTurnXco,"tuXmoXco"=tuXmoXco,"incor"=incor,
"moXincor"=moXincor,"coXincor"=coXincor,"coXmoXin"=coXmoXin,
"multim"=multim,"multiXco"=multiXco,"gamQuad"=gamQuad,
"modXgamQ"=modXgamQ,"block"=block,"blocXmod"=blocXmod)
mList = mList[rownames(modelComparison)]
varExplained = sapply(mList,MuMIn::r.squaredGLMM)
varExplained.fixed = diff(varExplained[1,])
t(t(varExplained.fixed[c("game","gamQuad","mtchTrn",
                     "tMtchTr","incor","modXcond",
                     "modXgame","modXgamQ")]))
```


Plot for cumulative matcher turn effects (ignore vocal condition who hardly respond).
Note that we found that the cumulative number of trials is a significant predictor, except when the number of trials is included in the model. This may be because the total number of trials is an upper bound on the total number of matcher responses and so the model uses cumulative matcher turns as a proxy for number of trials. In the raw data, there appears to be no relationship between cumulative matcher responses and trial length:

```{r eval=F}
ggplot(d[d$modalityCondition!="vocal",],
       aes(x=matcherResponds.cumulative,
           y=trialLength.log)) +
  stat_smooth() + geom_point()
```


\newpage

# Alternative models

## Model for only accurate trials

```{r}
accTrials =  lmer(trialLength.log ~ 1 + modalityCondition*condition*trialTotal +
             I(trialTotal^2) +(modalityCondition:I(trialTotal^2)) +
            matcherResponds*modalityCondition*condition +
            matcherResponds.cumulative + 
            matcherResponds.cumulative:modalityCondition +
            modalityCondition*condition +
            multimodal + multimodal:condition + 
            matcherResponds +
            firstBlock +
            (1 + condition |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d[!d$incorrect,], REML = TRUE)

aTF = summary(accTrials)$coefficients
fTF = summary(finalModel)$coefficients
cF = intersect(rownames(aTF),rownames(fTF))
aTF = aTF[cF,]
fTF = fTF[cF,]
plot(aTF[,1],fTF[,1])
abline(0,1)

# Print large differences in t-value
diffF = abs(aTF[,'t value'] - fTF[,'t value'])
diffFV = names(diffF[diffF> (2 * sd(fixef(finalModel)))])
round(cbind(all=fTF[diffFV,3],correct=aTF[diffFV,3]),3)
```

There are no large qualitative differences when analysing only correct trials.

\newpage

## Model for only multimodal trials

```{r}
multTrials =  lmer(trialLength.log ~ 1 + modalityCondition*condition*trialTotal +
             I(trialTotal^2) +(modalityCondition:I(trialTotal^2)) +
            matcherResponds*modalityCondition*condition +
            matcherResponds.cumulative + 
              matcherResponds.cumulative:modalityCondition +
            incorrect *modalityCondition*condition +
            matcherResponds +
            firstBlock +
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d[(d$modalityCondition!="multi") | (d$multimodal),], REML = TRUE)
aTF = summary(multTrials)$coefficients
fTF = summary(finalModel)$coefficients
cF = intersect(rownames(aTF),rownames(fTF))
aTF = aTF[cF,]
fTF = fTF[cF,]
plot(aTF[,1],fTF[,1])
abline(0,1)

# Print large differences in t-value
diffF = abs(aTF[,'t value'] - fTF[,'t value'])
diffFV = names(diffF[diffF> (2 * sd(fixef(finalModel)))])
round(cbind(all=fTF[diffFV,3],correct=aTF[diffFV,3]),3)

plot_model(multTrials,axis.labels = "")
plot_model(finalModel,axis.labels = "")
```

Summary:

We also analysed only correctly guessed trials and found no qualitative differences. Running the analysis while excluding trials with unimodal descriptions from the multimodal condition lead to weaker effects for condition, stimulus type and the interaction between the two. In line with the analysis above, this suggests that the advantage for participants in the multimodal condition is not just due to multimodal signals in themselves, but may be due to the relationship between multimodality and the communicative interaction between the director and matcher (see section 6.1).

\newpage

## Minimal model

Model including only variables that explained a significant amnount of variance according to the model comparison procedure above.

```{r}
model.min = lmer(trialLength.log ~ 1 +
            matcherResponds +
            incorrect +
            modalityCondition:trialTotal +
            trialTotal + I(trialTotal^2) +
            modalityCondition*condition +
            modalityCondition:I(trialTotal^2) +
            (1 + condition |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = FALSE,control = ctrl)
```

Compare the estimates:

```{r}
model.min.fe = fixef(model.min)
model.full.fe = fixef(finalModel)[names(model.min.fe)]
plot(model.min.fe,model.full.fe)
abline(0,1)
cor(model.min.fe,model.full.fe)
```

Estimates are correlated with r = `r signif(cor(model.min.fe,model.full.fe),2)`, suggesting that there is little difference.

Compare the t-values. Note that in almost all cases, the restuls for the minimal model are the same or stronger:

```{r}
getTval = function(X){summary(X)$coef[,"t value"]}
model.min.t = getTval(model.min)
model.full.t = getTval(finalModel)
model.full.t = model.full.t[names(model.min.t)]
plot(abs(model.min.t),abs(model.full.t))
abline(0,1)
```

## Alternative distribution

Below we run the final model from the procedure above, but fitting the raw trial length in milliseconds with a poisson distribution, rather than the log-transformed trial Length.

```{r cache=T}
block.poisson =  glmer(trialLength ~ 1 +
            modalityCondition*condition*trialTotal +
            I(trialTotal^2) +(modalityCondition:I(trialTotal^2)) +
            matcherResponds*modalityCondition*condition +
            matcherResponds.cumulative + 
            matcherResponds.cumulative:modalityCondition +
            incorrect * modalityCondition*condition +
            multimodal + multimodal:condition + 
            matcherResponds +
            firstBlock +
            (1 + condition + incorrect |dyadNumber/playerId) + 
            (1 + modalityCondition|itemId),
          data=d, REML = TRUE,
          family = poisson())

summary(block.poisson)
```

Compare estimates for the two distribution functions (the intercepts will obviously be different, so we ignore those):

```{r}
gaussian.fixef = fixef(block)
gaussian.fixef = gaussian.fixef[names(gaussian.fixef)!="(Intercept)"]
poisson.fixef = fixef(block.poisson)
poisson.fixef = poisson.fixef[names(poisson.fixef)!="(Intercept)"]

plot(gaussian.fixef,poisson.fixef)
abline(0,1)
cor(gaussian.fixef,poisson.fixef)
```

The estimates are highly correlated, suggesting that the choice to log-transform the trial length isn't particularly important.


# Summary results

```{r}
rownames(finalRes) = NULL
cbind(finalRes[,c("label","estimate","conf.low",'conf.high')],
      signif(finalRes[,c("wald.t","Chisq","Pr(>Chisq)")],2))
```